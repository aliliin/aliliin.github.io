<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go 微服务可用性设计</title>
    <link href="/2021/11/17/Go%20%E5%AD%A6%E4%B9%A0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/11/17/Go%20%E5%AD%A6%E4%B9%A0%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%94%A8%E6%80%A7%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-微服务可用性设计知识点"><a href="#Go-微服务可用性设计知识点" class="headerlink" title="Go 微服务可用性设计知识点"></a>Go 微服务可用性设计知识点</h1><h2 id="隔离"><a href="#隔离" class="headerlink" title="隔离"></a>隔离</h2><h3 id="服务隔离"><a href="#服务隔离" class="headerlink" title="服务隔离"></a>服务隔离</h3><h4 id="动静隔离"><a href="#动静隔离" class="headerlink" title="动静隔离"></a>动静隔离</h4><p>如 CND 缓存加速、mysql LRU 算法改进</p><p>业务可以拆成两张表，静态表（字段机会不会改）和动态表（字段经常改）</p><h3 id="读写隔离"><a href="#读写隔离" class="headerlink" title="读写隔离"></a>读写隔离</h3><ul><li>主从</li><li>CQRS</li></ul><h3 id="轻重隔离"><a href="#轻重隔离" class="headerlink" title="轻重隔离"></a>轻重隔离</h3><ul><li>核心：服务按核心与否进行分离，越核心的服务可用性要求也高</li><li>快慢</li><li>热点<ul><li>小表广播: 存为到内存，定期更新</li><li>主动预热：旁路预热</li></ul></li></ul><h3 id="物理隔离"><a href="#物理隔离" class="headerlink" title="物理隔离"></a>物理隔离</h3><ul><li>线程：使用线程池，不同业务逻辑用不同的池子</li><li>进程：容器化</li><li>集群：region.zone.cluster.appid</li><li>机房</li></ul><h2 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h2><p>核心理念： fail fast</p><h3 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h3><ul><li>网络具有不确定性</li><li>客户端和服务端不一致的超时策略</li></ul><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><ul><li>进程内：每一个请求前查看是否有剩余时间，并继承超时策略</li><li>服务间： GRPC 支持基于 grpc-timeout 的 Header 传递</li><li>监控要看 95th、99th</li></ul><h2 id="过载保护"><a href="#过载保护" class="headerlink" title="过载保护"></a>过载保护</h2><h3 id="常见限流算法"><a href="#常见限流算法" class="headerlink" title="常见限流算法"></a>常见限流算法</h3><ul><li>令牌桶：按固定速率往桶里加令牌，可以消费多个令牌</li><li>漏斗桶： 按固定速率流出水滴，可以以任意速率流入水滴</li></ul><p>痛点：阈值不好设置</p><h3 id="自适应过载保护"><a href="#自适应过载保护" class="headerlink" title="自适应过载保护"></a>自适应过载保护</h3><p>inflight: 当前服务正在进行的请求数量（atomic.add 来加减）<br>pass: 每个采样窗口内成功的请求数<br>rt: 单个采样窗口的平均 响应时间</p><p>CPU 统计：使用独立的 goroutine 每隔 250ms 统计一次，计算均值时，使用简单滑动平均（考虑前一次的均值）去除峰值的影响</p><p>统计 CPU 的滑动均值作为启发阈值(如 80%)，一旦触发进入过载保护阶段，算法：(pass * rt) &lt; inflight</p><p>另外过载保护需要保证持续最小时间如 2s，以避免一个短时间的 CPU 下降可能导致大量请求被放行，严重是会打满 CPU</p><h2 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h2><p>定义：在一段时间内某个客户或应用可以处理多少个请求</p><p>作用：过滤流量峰值</p><h3 id="常规方案"><a href="#常规方案" class="headerlink" title="常规方案"></a>常规方案</h3><ul><li>令牌桶：针对单个节点无法分布式限流</li><li>QPS 限流：<ul><li>不同的请求可能消耗的资源完全不同</li><li>静态阈值很难设置准确</li></ul></li><li>使用 redis 分布式限流<ul><li>单个大流量接口容易产生热点 key</li><li>每次请求需要拿一个 quota –&gt; 优化：基于历史窗口数据批量拿 quota，减少请求 redis 频次</li></ul></li></ul><h3 id="资源分配：Max-Min-Fairness-算法"><a href="#资源分配：Max-Min-Fairness-算法" class="headerlink" title="资源分配：Max-Min Fairness 算法"></a>资源分配：Max-Min Fairness 算法</h3><h3 id="重要性-criticality"><a href="#重要性-criticality" class="headerlink" title="重要性 criticality"></a>重要性 criticality</h3><ul><li>将请求按重要性分级，配额不足时，先拒绝优先级低的<ul><li>critical_plus</li><li>critical</li><li>sheddable_plus</li><li>sheddable</li></ul></li><li>通常 BFF 层接口分级，重要性可往下游传递</li></ul><h3 id="熔断：-客户端自适应节流"><a href="#熔断：-客户端自适应节流" class="headerlink" title="熔断： 客户端自适应节流"></a>熔断： 客户端自适应节流</h3><p>请求拒绝率： max(0, requests - K * accepts/(requests+1))</p><h3 id="客户端流控"><a href="#客户端流控" class="headerlink" title="客户端流控"></a>客户端流控</h3><p>作用：避免 positive feedback 积极重试访问不可达的服务</p><ul><li>限制请求频次，重试添加 backoff 退让策略</li></ul><h3 id="Gutter"><a href="#Gutter" class="headerlink" title="Gutter"></a>Gutter</h3><p>gutter 集群只需要主集群的 10%的资源<br>主集群发生熔断被抛弃的请求会转移到 gutter 集群<br>如果 gutter 集群也接受不住流量，会重现抛到主集群</p><h2 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h2><p>本质为提供有损服务<br>通过降低回复的质量来答复以减少所需的计算量或时间</p><p>通常采用错误或者 CPU 指标作为决定性指标</p><p>通常在 BFF 层或网关来做</p><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>随机化+指数避让</p><p>只应该在失败层重试，以免指数放大次数，如收到 503 就表示下游已重试过则直接往上抛结果当前层不在重试了</p><p>业务不幂等：尽量不重试，即使重试也需要避免数据发生重复</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><ul><li>均衡流量分发</li><li>识别异常节点</li><li>水平扩容</li><li>高可用 N+2</li></ul><h3 id="可能的问题"><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h3><ul><li>不同节点负载不一样<ul><li>原因：<ul><li>不同请求处理成本不一样</li><li>机器性能不一样</li><li>可能有节点 FullGC 中</li><li>多个 LB 中每个 LB 都没有全局视角</li></ul></li></ul></li></ul><h3 id="Power-of-Two-Choices-P2C"><a href="#Power-of-Two-Choices-P2C" class="headerlink" title="Power of Two Choices (P2C)"></a>Power of Two Choices (P2C)</h3><p>随机请两个节点进行打分，选择更优的节点</p><p>打分：服务端 CPU(通过 rpc response head 获取)、耗时、成功率，inflight</p><p>新加入节点开始权重较小，这个特性尤其对 Java 服务比较友好</p><p>指标计算结合滑动均值且使用时间衰减</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://github.com/golang/time/blob/master/rate/rate.go">令牌桶实现</a></li><li><a href="https://github.com/uber-go/ratelimit/tree/v0.1.0">uber 漏斗桶</a></li><li><a href="https://github.com/afex/hystrix-go/blob/master/hystrix/rolling/rolling.go">hystrix-go 滑动窗口</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go goroutine 并发编程</title>
    <link href="/2021/11/12/Go%20goroutine%20%E5%B9%B6%E5%8F%91/"/>
    <url>/2021/11/12/Go%20goroutine%20%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="对自己创建的-goroutine-负责"><a href="#对自己创建的-goroutine-负责" class="headerlink" title="对自己创建的 goroutine 负责"></a>对自己创建的 goroutine 负责</h3><ol><li> <strong>请将是否异步调用的选择权交给调用者</strong>，不然很有可能大家并不知道你在这个函数里面使用了 goroutine</li><li>如果你要启动一个 goroutine 请对它负责<ol><li> <strong>永远不要启动一个你无法控制它退出，或者你无法知道它何时推出的 goroutine</strong></li><li> 启动 goroutine 时请加上 panic recovery 机制，避免服务直接不可用</li><li> 造成 goroutine 泄漏的主要原因就是 goroutine 中造成了阻塞，并且没有外部手段控制它退出</li></ol></li><li> <strong>尽量避免在请求中直接启动 goroutine 来处理问题</strong>，而应该通过启动 worker 来进行消费，这样可以避免由于请求量过大，而导致大量创建 goroutine 从而导致 oom，当然如果请求量本身非常小，没啥问题了</li></ol><h3 id="基于-errgroup-实现一个-http-server-的启动和关闭-，以及-linux-signal-信号的注册和处理，要保证能够一个退出，全部注销退出。"><a href="#基于-errgroup-实现一个-http-server-的启动和关闭-，以及-linux-signal-信号的注册和处理，要保证能够一个退出，全部注销退出。" class="headerlink" title="基于 errgroup 实现一个 http server 的启动和关闭 ，以及 linux signal 信号的注册和处理，要保证能够一个退出，全部注销退出。"></a>基于 errgroup 实现一个 http server 的启动和关闭 ，以及 linux signal 信号的注册和处理，要保证能够一个退出，全部注销退出。</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>group, ctx := errgroup.WithContext(context.Background())<br><br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintln(w, <span class="hljs-string">&quot;Hello Go&quot;</span>)<br>&#125;)<br><br>server := http.Server&#123;<br>Handler: mux,<br>Addr:    <span class="hljs-string">&quot;:8889&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 利用无缓冲chan 模拟单个服务错误退出</span><br>serverOut := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>mux.HandleFunc(<span class="hljs-string">&quot;/shutdown&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>serverOut &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// 阻塞</span><br>&#125;)<br><br><span class="hljs-comment">// -- 测试 http server 的启动和退出 --</span><br><br><span class="hljs-comment">// g1 启动http server服务</span><br><span class="hljs-comment">// g1 退出后, context 将不再阻塞，g2, g3 都会随之退出</span><br>group.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">return</span> server.ListenAndServe()<br>&#125;)<br><br><span class="hljs-comment">// g2</span><br><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 也会退出</span><br>group.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-serverOut:<br>fmt.Println(<span class="hljs-string">&quot;server closed&quot;</span>) <span class="hljs-comment">// 退出会触发 g.cancel, ctx.done 会收到信号</span><br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>fmt.Println(<span class="hljs-string">&quot;errgroup exit&quot;</span>)<br>&#125;<br><br>timeoutCtx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">3</span>*time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br>log.Println(<span class="hljs-string">&quot;shutting down server...&quot;</span>)<br><span class="hljs-keyword">return</span> server.Shutdown(timeoutCtx)<br>&#125;)<br><br><span class="hljs-comment">// g3 linux signal 信号的注册和处理</span><br><span class="hljs-comment">// g3 捕获到 os 退出信号将会退出</span><br><span class="hljs-comment">// g3 退出后, context 将不再阻塞，g2 会随之退出</span><br><span class="hljs-comment">// g2 退出时，调用了 shutdown，g1 会退出</span><br>group.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// sigint 用户ctrl+c, sigterm程序退出</span><br>signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ctx.Done():<br><span class="hljs-keyword">return</span> ctx.Err()<br><span class="hljs-keyword">case</span> sig := &lt;-quit:<br><span class="hljs-keyword">return</span> errors.Errorf(<span class="hljs-string">&quot;get os exit: %v&quot;</span>, sig)<br>&#125;<br>&#125;)<br><br><span class="hljs-comment">// 然后 main 函数中的 g.Wait() 退出，所有协程都会退出</span><br>err := group.Wait()<br>fmt.Println(err)<br>fmt.Println(ctx.Err())<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go error</title>
    <link href="/2021/10/27/Go%20Error/"/>
    <url>/2021/10/27/Go%20Error/</url>
    
    <content type="html"><![CDATA[<h3 id="panic-or-error"><a href="#panic-or-error" class="headerlink" title="panic or error"></a>panic or error</h3><ol><li>在 Go 中 panic 会导致程序直接退出，是一个致命的错误，如果使用 panic recover 进行处理的话，会存在很多问题<ol><li>性能问题，频繁 panic recover 性能不好</li><li>容易导致程序异常退出，只要有一个地方没有处理到就会导致程序进程整个退出</li><li>不可控，一旦 panic 就将处理逻辑移交给了外部，我们并不能预设外部包一定会进行处理</li></ol></li><li>什么时候使用 panic 呢？<ol><li>对于真正意外的情况，那些表示不可恢复的程序错误，例如索引越界、不可恢复的环境问题、栈溢出，我们才使用 panic</li></ol></li><li>使用 error 处理有哪些好处？<ol><li>简单。</li><li>考虑失败，而不是成功(Plan for failure, not success)。</li><li>没有隐藏的控制流。</li><li>完全交给你来控制 error。</li><li>Error are values。</li></ol></li><li>在程序启动的时候，如果有强依赖的服务出现故障时 <code>panic</code> 退出</li><li>在程序启动的时候，如果发现有配置明显不符合要求， 可以 <code>panic</code> 退出（防御编程）</li><li>其他情况下只要不是不可恢复的程序错误，都不应该直接 <code>panic</code> 应该返回 <code>error</code></li><li>在程序入口处，例如 <code>gin</code> 中间件需要使用 <code>recover</code> 预防 <code>panic</code> 程序退出</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Channel 通道</title>
    <link href="/2021/10/08/Go%20Channels%20%E9%80%9A%E9%81%93%20/"/>
    <url>/2021/10/08/Go%20Channels%20%E9%80%9A%E9%81%93%20/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-channel"><a href="#Go-channel" class="headerlink" title="Go channel"></a>Go channel</h1><h3 id="基本语法和需要注意的点"><a href="#基本语法和需要注意的点" class="headerlink" title="基本语法和需要注意的点"></a>基本语法和需要注意的点</h3><ol><li>语法定义</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> channel <span class="hljs-keyword">chan</span> [<span class="hljs-keyword">type</span>]<br></code></pre></td></tr></table></figure><pre><code>* 使用 `&lt;-` 传递数据* `chan &lt;- data` 发送数据到通道，向通道中写数据* `data &lt;- chan` 获取通道中的数据，从通道中读取数据</code></pre><ol start="2"><li>注意的点<ul><li>它是用于 <code>goroutine</code> 之间进行传递消息的</li><li>每个 <code>channel</code> 都有相关联的数据类型, <code>nil chan</code>不能使用</li><li><code>channel</code> 是在 <code>goroutine</code> 之间链接，数据接收和发送必须处于不同的 <code>goroutine</code>中</li><li>非缓冲通道发送数据和读取数据都是阻塞的，直到另一条 <code>goroutine </code>执行读取或写完数据才会解除阻塞</li><li><code>channel</code> 是同步的，就意味着同一时间，只能有一条 <code>goroutine </code>来操作</li><li>不要忘记 <code>close(channel)</code> 关闭通道</li></ul></li></ol><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 创建通道</span><br><span class="hljs-keyword">var</span> channel <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span><br>fmt.Printf(<span class="hljs-string">&quot;%T,%v\n&quot;</span>, channel, channel) <span class="hljs-comment">// chan int,&lt;nil&gt;</span><br>channel = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%T,%v\n&quot;</span>, channel, channel) <span class="hljs-comment">// chan int,0xc00008c060</span><br><br><span class="hljs-comment">// 通道内写入数据</span><br><span class="hljs-keyword">go</span> setData(channel)<br><span class="hljs-comment">// 读取通道内的数据</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> channel &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取的数据: &quot;</span>, v) <span class="hljs-comment">// 读取的数据：0，1，2，3，4</span><br>&#125;<br><br><span class="hljs-comment">// 非缓冲通道</span><br><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span><br>ch1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;子的 goroutine 中，i&quot;</span>, i) <span class="hljs-comment">// 子的 goroutine 中，i 0，1，2，3，4</span><br>&#125;<br><span class="hljs-comment">// 循环结束后向通道中写数据，表示结束了。</span><br>ch1 &lt;- <span class="hljs-number">1</span><br>fmt.Println(<span class="hljs-string">&quot;结束&quot;</span>)<br>&#125;()<br><br>data := &lt;-ch1<br>fmt.Println(<span class="hljs-string">&quot;main data --&gt; &quot;</span>, data)<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">缓冲通道（固定大小）</span><br><span class="hljs-comment">接收：缓冲区数据空了会阻塞</span><br><span class="hljs-comment">写入：缓冲区数据满了会阻塞</span><br><span class="hljs-comment">*/</span><br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(ch2), <span class="hljs-built_in">cap</span>(ch2)) <span class="hljs-comment">// 0 ,3</span><br>ch2 &lt;- <span class="hljs-number">1</span><br>ch2 &lt;- <span class="hljs-number">2</span><br>ch2 &lt;- <span class="hljs-number">3</span><br>fmt.Println(<span class="hljs-built_in">len</span>(ch2), <span class="hljs-built_in">cap</span>(ch2)) <span class="hljs-comment">// 3,3</span><br><span class="hljs-comment">// 缓冲区满了，如果需要继续写入数据，需要有其他的 goroutine 进行读取（队列的结构来读取）</span><br><span class="hljs-comment">// ch2 &lt;- 4</span><br>ch3 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">3</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(ch3), <span class="hljs-built_in">cap</span>(ch3)) <span class="hljs-comment">// 0 ,3</span><br><span class="hljs-keyword">go</span> setStringData(ch3, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> &#123;<br>v, ok := &lt;-ch3<br><span class="hljs-keyword">if</span> !ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;读取完毕&quot;</span>, ok) <span class="hljs-comment">// 读取完毕 false</span><br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;读取的数据是：&quot;</span>, v) <span class="hljs-comment">// 读取的数据是： 0,1,2</span><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">双向通道</span><br><span class="hljs-comment">chan ch</span><br><span class="hljs-comment">chan &lt;- data 写入数据</span><br><span class="hljs-comment">data &lt;- chan 读取数据</span><br><span class="hljs-comment">*/</span><br>ch4 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)<br>isDone := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br><span class="hljs-keyword">go</span> SendString(ch4, isDone)<br>data1 := &lt;-ch4        <span class="hljs-comment">// 读取</span><br>fmt.Println(data1)    <span class="hljs-comment">// golang</span><br>ch4 &lt;- <span class="hljs-string">&quot;learn golang&quot;</span> <span class="hljs-comment">// 发送</span><br><br>&lt;-isDone <span class="hljs-comment">// 判断这个来看主程序结束</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">单向通道：定向</span><br><span class="hljs-comment">chan &lt;- Write 只支持写</span><br><span class="hljs-comment">    &lt;- chan Read 只能读</span><br><span class="hljs-comment">*/</span><br>singleChanWrite := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>) <span class="hljs-comment">// 只能写，不能读</span><br>singleChanRead := <span class="hljs-built_in">make</span>(&lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)  <span class="hljs-comment">// 只能读，不能写</span><br><br>fmt.Println(<span class="hljs-string">&quot;main over&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setData</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br>ch &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 通知对方，通道关闭</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">setStringData</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, number <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; number; i++ &#123;<br>ch &lt;- strconv.Itoa(i)<br>&#125;<br><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 通知对方，通道关闭</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SendString</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, isDone <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>ch &lt;- <span class="hljs-string">&quot;golang&quot;</span>                            <span class="hljs-comment">// 发送</span><br>data2 := &lt;-ch                             <span class="hljs-comment">// 读取数据</span><br>fmt.Println(<span class="hljs-string">&quot;main goroutine 传来: &quot;</span>, data2) <span class="hljs-comment">// main goroutine 传来:   learn golang</span><br><br>isDone &lt;- <span class="hljs-literal">true</span> <span class="hljs-comment">// 限制主程序过快的结束执行</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac系统安装java11之后使用Nacos</title>
    <link href="/2021/09/16/%E8%A7%A3%E5%86%B3Mac%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85java11%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8Nacos%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/09/16/%E8%A7%A3%E5%86%B3Mac%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85java11%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8Nacos%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="修改启动代码"><a href="#修改启动代码" class="headerlink" title="修改启动代码"></a>修改启动代码</h3><blockquote><p>修改启动代码之前，要配置好 PATH</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">在 Nacos-Server 的 bin / startup.sh<br>由 JAVA_OPT_EXT_FIX 配置引起启动报错<br><br>在startup.sh文件中替换下方配置<br><br>x JAVA_OPT_EXT_FIX=<span class="hljs-string">&quot;-Djava.ext.dirs=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre/lib/ext:<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/lib/ext&quot;</span><br>√ JAVA_OPT=<span class="hljs-string">&quot;<span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> -Djava.ext.dirs=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre/lib/ext:<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/lib/ext&quot;</span><br><br>x <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$JAVA</span> <span class="hljs-variable">$JAVA_OPT_EXT_FIX</span> <span class="hljs-variable">$&#123;JAVA_OPT&#125;</span>&quot;</span><br>√ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$JAVA</span> <span class="hljs-variable">$&#123;JAVA_OPT&#125;</span>&quot;</span><br><br>x <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$JAVA</span> <span class="hljs-variable">$JAVA_OPT_EXT_FIX</span> <span class="hljs-variable">$&#123;JAVA_OPT&#125;</span>&quot;</span> &gt; <span class="hljs-variable">$&#123;BASE_DIR&#125;</span>/logs/start.out 2&gt;&amp;1 &amp;<br>x nohup <span class="hljs-string">&quot;<span class="hljs-variable">$JAVA</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$JAVA_OPT_EXT_FIX</span>&quot;</span> <span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> nacos.nacos &gt;&gt; <span class="hljs-variable">$&#123;BASE_DIR&#125;</span>/logs/start.out 2&gt;&amp;1 &amp;<br>√ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$JAVA</span> <span class="hljs-variable">$&#123;JAVA_OPT&#125;</span>&quot;</span> &gt; <span class="hljs-variable">$&#123;BASE_DIR&#125;</span>/logs/start.out 2&gt;&amp;1 &amp;<br>√ nohup <span class="hljs-variable">$JAVA</span> <span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> nacos.nacos &gt;&gt; <span class="hljs-variable">$&#123;BASE_DIR&#125;</span>/logs/start.out 2&gt;&amp;1 &amp;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 使用 Consul 的简单操作</title>
    <link href="/2021/09/14/Consul%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/09/14/Consul%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<ul><li><p>Consul Docker 安装命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d -p 8500:8500 -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8600:8600/udp consul consul agent -dev -client=0.0.0.0<br><br>// 开机关机 自动重启服务<br>docker container update --restart=always 容器ID<br><br>默认的web端口号是：8500<br>默认的 dns 端口号是：8600，<br>dig 命令查询<br>dig @127.0.0.1 -p 8600 consul.service.consul SRV<br><br><br></code></pre></td></tr></table></figure></li><li><p>Consul 服务注册</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8500</span><span class="hljs-regexp">/v1/</span>agent<span class="hljs-regexp">/service/</span>register  PUT请求<br>headers 里面需要写 Content-Type  application/json<br>body 选 raw json<br></code></pre></td></tr></table></figure><p>参数如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;Name&quot;</span>: <span class="hljs-string">&quot;shop_web&quot;</span>,<br>  <span class="hljs-attr">&quot;ID&quot;</span>: <span class="hljs-string">&quot;shop_web&quot;</span>,<br>  <span class="hljs-attr">&quot;Tags&quot;</span>: [<span class="hljs-string">&quot;shop_api&quot;</span>, <span class="hljs-string">&quot;user_api&quot;</span>, <span class="hljs-string">&quot;shop&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>],<br>  <span class="hljs-attr">&quot;Address&quot;</span>: <span class="hljs-string">&quot;127.0.0.1&quot;</span>,<br>  <span class="hljs-attr">&quot;Port&quot;</span>: <span class="hljs-number">8088</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注册的时候添加健康检查</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go">improt <span class="hljs-string">&quot;github.com/hashicorp/consul/api&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Register</span><span class="hljs-params">(address <span class="hljs-keyword">string</span>, port <span class="hljs-keyword">int</span>, name <span class="hljs-keyword">string</span>, tags []<span class="hljs-keyword">string</span>, id <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<br>cfg := api.DefaultConfig()<br>cfg.Address = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br><br>client, err := api.NewClient(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 生成对应的检查对象</span><br>check := &amp;api.AgentServiceCheck&#123;<br>HTTP:                           <span class="hljs-string">&quot;http://192.168.10.178:8089/health&quot;</span>,<br>Timeout:                        <span class="hljs-string">&quot;5s&quot;</span>,<br>Interval:                       <span class="hljs-string">&quot;5s&quot;</span>,<br>DeregisterCriticalServiceAfter: <span class="hljs-string">&quot;10s&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 生成注册对象</span><br>registration := <span class="hljs-built_in">new</span>(api.AgentServiceRegistration)<br>registration.Name = name<br>registration.ID = id<br>registration.Port = port<br>registration.Address = address<br>registration.Tags = tags<br>registration.Check = check<br><br>err = client.Agent().ServiceRegister(registration)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>Register(<span class="hljs-string">&quot;192.168.10.178&quot;</span>, <span class="hljs-number">8089</span>, <span class="hljs-string">&quot;user_web&quot;</span>, []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;shop&quot;</span>, <span class="hljs-string">&quot;user&quot;</span>&#125;, <span class="hljs-string">&quot;user_web&quot;</span>)<br></code></pre></td></tr></table></figure><p>查询所有已经注册过的服务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AllServices</span><span class="hljs-params">()</span></span> &#123;<br>cfg := api.DefaultConfig()<br>cfg.Address = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br>client, err := api.NewClient(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>data, err := client.Agent().Services()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> data &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获取指定的服务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FilterServices</span><span class="hljs-params">()</span></span> &#123;<br>cfg := api.DefaultConfig()<br>cfg.Address = <span class="hljs-string">&quot;127.0.0.1:8500&quot;</span><br>client, err := api.NewClient(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>data, err := client.Agent().ServicesWithFilter(<span class="hljs-string">`Service == &quot;user_web&quot;`</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> data &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Consul 服务注销</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8500</span><span class="hljs-regexp">/v1/</span>agent<span class="hljs-regexp">/service/</span>deregister/这里是服务的ID  PUT请求<br></code></pre></td></tr></table></figure></li><li><p>Grpc 下添加 Consul 服务</p><p>添加指定的包</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;google.golang.org/grpc/health/grpc_health_v1&quot;</span><br><br><span class="hljs-comment">// 服务器启动监听后添加</span><br>grpc_health_v1.RegisterHealthServer(server, health.NewServer())<br><span class="hljs-comment">// 服务注册</span><br>cfg := api.DefaultConfig()<br>cfg.Address = fmt.Sprintf(<span class="hljs-string">&quot;%s:%d&quot;</span>, global.ServerConfig.ConsulInfo.Host, global.ServerConfig.ConsulInfo.Port)<br>client, err := api.NewClient(cfg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">// 生成对应的检查对象</span><br>check := &amp;api.AgentServiceCheck&#123;<br>GRPC:                           fmt.Sprintf(<span class="hljs-string">&quot;192.168.10.178:8088&quot;</span>),<br>Timeout:                        <span class="hljs-string">&quot;5s&quot;</span>,<br>Interval:                       <span class="hljs-string">&quot;5s&quot;</span>,<br>DeregisterCriticalServiceAfter: <span class="hljs-string">&quot;15s&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 生成注册对象</span><br>registration := <span class="hljs-built_in">new</span>(api.AgentServiceRegistration)<br>registration.Name = global.ServerConfig.Name<br>registration.ID = global.ServerConfig.Name<br>registration.Port = *Port<br>registration.Address = <span class="hljs-string">&quot;192.168.10.178&quot;</span><br>registration.Tags = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;shop&quot;</span>, <span class="hljs-string">&quot;shop_srv&quot;</span>&#125;<br>registration.Check = check<br><br>err = client.Agent().ServiceRegister(registration)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>web 端需要完成服务注册和服务发现</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Consul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP 实现 AES-128-CBC-PKCS5Padding 加密</title>
    <link href="/2021/08/30/PHP%E5%AE%9E%E7%8E%B0AES-128-CBC-PKCS5Padding%E5%8A%A0%E5%AF%86/"/>
    <url>/2021/08/30/PHP%E5%AE%9E%E7%8E%B0AES-128-CBC-PKCS5Padding%E5%8A%A0%E5%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="PHP-实现-AES-128-CBC-PKCS5Padding-加密"><a href="#PHP-实现-AES-128-CBC-PKCS5Padding-加密" class="headerlink" title="PHP 实现 AES-128-CBC-PKCS5Padding 加密"></a>PHP 实现 AES-128-CBC-PKCS5Padding 加密</h3><blockquote><p>最近在工作中负责对接 API，数据接⼝交互过程中，不可避免会有⼀些敏感数据的传输，为了使数据交互更加安全，因此对数据进行加密。对方的要求是对接口的业务数据进行 <code>AES-128-CBC-PKCS5Padding</code> 加密，然后再做 <code>Base64 </code>编码将得到的最终字符串进行提交，也给到了加密方式对应的密钥(key)和初始化向量（偏移量）。</p></blockquote><p>​ 首先看到这个加密方式之后，就在 PHP 函数库中进行寻找，看看有没有对应的加密函数，然而找了一圈下来，发现并没有，需要自己实现，后了解到可以用 mcrypt 函数扩展实现，但是 mcrypt 函数 自 PHP 7.1.0 起就废弃了，强烈建议不要使用本函数，只好再寻找其他<a href="https://www.php.net/manual/zh/refs.crypto.php">加密函数库</a>，在手册的下方看到了 <a href="https://www.php.net/manual/zh/ref.openssl.php">OpenSSL 函数</a>，通过了解 <a href="https://www.php.net/manual/zh/function.openssl-encrypt.php">openssl_encrypt(加密数据)</a> 函数发现可以实现需求,<a href="https://www.php.net/manual/zh/function.openssl-encrypt.php">openssl_encrypt</a> 具体的使用方法请自行看手册，</p><h4 id="实现函数如下："><a href="#实现函数如下：" class="headerlink" title="实现函数如下："></a>实现函数如下：</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 加密<br><span class="hljs-keyword">function</span> encrypt(<span class="hljs-variable">$input</span>, <span class="hljs-variable">$key</span>, <span class="hljs-variable">$iv</span>)&#123;<br>    return base64_encode(openssl_encrypt(<span class="hljs-variable">$input</span>, <span class="hljs-string">&#x27;AES-128-CBC&#x27;</span>, <span class="hljs-variable">$key</span>, OPENSSL_RAW_DATA,<span class="hljs-variable">$iv</span>));<br>&#125;<br><br><span class="hljs-regexp">//</span> 解密<br><span class="hljs-keyword">function</span> decrypt(<span class="hljs-variable">$input</span>, <span class="hljs-variable">$key</span>, <span class="hljs-variable">$iv</span>)&#123;<br>    return openssl_decrypt(base64_decode(<span class="hljs-variable">$input</span>), <span class="hljs-string">&#x27;AES-128-CBC&#x27;</span>, <span class="hljs-variable">$key</span>, OPENSSL_RAW_DATA, <span class="hljs-variable">$iv</span>);<br>&#125;<br><br><span class="hljs-regexp">//</span> 测试加密 (我这里用的是json字符串)<br><span class="hljs-variable">$dataJson</span> = <span class="hljs-string">&#x27;[&#123;&quot;Code&quot;: &quot;123123&quot;, &quot;Name&quot;: &quot;Bob&quot;, &quot;Address&quot;: &quot;\u94f6\u5ddd\u5e02&quot;&#125;, &#123;&quot;Code&quot;: &quot;464776&quot;, &quot;Name&quot;: &quot;Hello&quot;, &quot;Address&quot;: &quot;\u5317\u4eac\u5e02&quot;&#125;]&#x27;</span>;<br>print_r(encrypt(<span class="hljs-variable">$dataJson</span>, <span class="hljs-variable">$key</span>, <span class="hljs-variable">$iv</span>));<br><span class="hljs-regexp">//u</span>9Bd8oHXDGvjZcTIX9HK1r1q+aSu+<span class="hljs-regexp">/48gsfoGVrxoScZuX8yaj/</span>xco8F2yHt2T987JNHil9LwjAmu9o5NJaicWQDaiKwMD5o70k1A9bGjDd71xb4hXRx3ddZwI85oTQQEUQLadR5C759SdaN8AOxlzH+yGlAWTOaEleulKoRTwaknG1NCM/qIRQ8gI5lzv+D<br><br><span class="hljs-regexp">//</span> 测试解密<br><span class="hljs-variable">$strr</span> = <span class="hljs-string">&#x27;u9Bd8oHXDGvjZcTIX9HK1r1q+aSu+/48gsfoGVrxoScZuX8yaj/xco8F2yHt2T987JNHil9LwjAmu9o5NJaicWQDaiKwMD5o70k1A9bGjDd71xb4hXRx3ddZwI85oTQQEUQLadR5C759SdaN8AOxlzH+yGlAWTOaEleulKoRTwaknG1NCM/qIRQ8gI5lzv+D&#x27;</span>;<br>print_r(decrypt(<span class="hljs-variable">$strr</span>, <span class="hljs-variable">$key</span>, <span class="hljs-variable">$iv</span>));<br><span class="hljs-regexp">//</span> [&#123;<span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-string">&quot;123123&quot;</span>, <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;Address&quot;</span>: <span class="hljs-string">&quot;\u94f6\u5ddd\u5e02&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;Code&quot;</span>: <span class="hljs-string">&quot;464776&quot;</span>, <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;Address&quot;</span>: <span class="hljs-string">&quot;\u5317\u4eac\u5e02&quot;</span>&#125;]<br></code></pre></td></tr></table></figure><p>自测通过，一脸得意地坐等联调。然后开始写其他业务去了，过了几天，结果一联调发现我加密的对方无法解密，对方加密的我无法解密，加密算法不匹配（挠头中。经过 Google 搜索相关问题，发现一句话(如下图），大概的意思就是说，在废弃的 <code>mcrypt</code> 加密库中，128 实际上指的是块大小而不是密钥大小，但是在 <code>openssl</code> 中的 <code>aes-128-cbc</code> 的 128 指的是密钥大小，也就是说，在使用有效的 256 位密钥时，它们都是 <code>aes-256</code> ，而如果要把 <code>mcrypt</code> 转为 <code>openssl</code> 的加密方式，<code>mcrypt</code> 的 128 需要写成 <code>openssl</code> 的 256 ，于是抱着试试看的态度，更改了一下 <code>aes-128-cbc</code> 为 <code>aes-256-cbc</code>，然后再进行调试，发现联调通过了。不过具体的技术细节原理还不是很明白，先这样子修改使用，以后有时间再研究吧。</p><p><img src="/images/aes-128-cbc.png"></p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul><li>解决的方案，是把加密方式 <code>AES-128-CBC</code> 替换成 <code>AES-256-CBC</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言的切片插入和删除</title>
    <link href="/2021/08/26/go%E5%88%87%E7%89%87%E7%9A%84%E6%96%B0%E5%A2%9E%E5%92%8C%E5%88%A0%E9%99%A4/"/>
    <url>/2021/08/26/go%E5%88%87%E7%89%87%E7%9A%84%E6%96%B0%E5%A2%9E%E5%92%8C%E5%88%A0%E9%99%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="golang-的切片插入和删除操作"><a href="#golang-的切片插入和删除操作" class="headerlink" title="golang 的切片插入和删除操作"></a>golang 的切片插入和删除操作</h2><h3 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s := []int&#123;1, 2, 4, 7&#125;</span><br><span class="line"></span><br><span class="line">// 结果应该是 5, 1, 2, 4, 7</span><br><span class="line">s = Add(s, 0, 5)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">// 结果应该是5, 9, 1, 2, 4, 7</span><br><span class="line">s = Add(s, 1, 9)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">// 结果应该是5, 9, 1, 2, 4, 7, 13</span><br><span class="line">s = Add(s, 6, 13)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">// 结果应该是5, 9, 2, 4, 7, 13</span><br><span class="line">s = Delete(s, 2)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">// 结果应该是9, 2, 4, 7, 13</span><br><span class="line">s = Delete(s, 0)</span><br><span class="line">fmt.Println(s)</span><br><span class="line">// 结果应该是9, 2, 4, 7</span><br><span class="line">s = Delete(s, 4)</span><br><span class="line">fmt.Println(s)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="新增任意位置"><a href="#新增任意位置" class="headerlink" title="新增任意位置"></a>新增任意位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Add(s []int, index int, value int) []int &#123;</span><br><span class="line">return append(s[:index], append([]int&#123;value&#125;, s[index:]...)...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除任意位置"><a href="#删除任意位置" class="headerlink" title="删除任意位置"></a>删除任意位置</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Delete(s []int, index int) []int &#123;</span><br><span class="line">return append(s[:index], s[index+1:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker中常用的命令</title>
    <link href="/2021/04/20/Docker%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    <url>/2021/04/20/Docker%E5%B8%B8%E7%94%A8%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="Docker-中常用的命令"><a href="#Docker-中常用的命令" class="headerlink" title="Docker 中常用的命令"></a>Docker 中常用的命令</h3><ul><li>启动容器<br><code>docker start</code></li><li>启动容器并进入 交互式模式<br><code>docker run -it 镜像name sh</code></li><li>进入容器内部<br><code>docker exec -it 镜像id sh</code></li><li>查看正在运行的容器<br><code>docker ps</code></li><li>停止正在运行的容器<br><code> docker stop</code></li><li>删除容器<br><code>docker rmi 删除的镜像</code></li><li>显示本地镜像<br><code>docker list</code></li><li>删除所有容器<br><code>docker rm -f $(docker ps -aq)</code></li><li>删除所有镜像<br><code>docker rmi $(docker images -q)</code></li><li>查看一个容器里面的程序进程信息<br><code>docker top 镜像id</code></li><li>镜像搜索<br><code>docker search</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 常见指令</title>
    <link href="/2021/04/02/Vue%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/"/>
    <url>/2021/04/02/Vue%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-常见指令"><a href="#Vue-常见指令" class="headerlink" title="Vue 常见指令"></a>Vue 常见指令</h1><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- v-text：在元素当中插入值 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&#x27;singer&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- v-for：根据变量的值来循环渲染元素 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span>&gt;</span></span><br><span class="xml">        </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml">--</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">index</span>&#125;&#125;</span><span class="xml"></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- v-if和v-else：根据表达式的真假值来动态插入和移除元素 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;isShow&quot;</span>&gt;</span>我会显示<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">v-else</span>&gt;</span>我不会显示，但是我要跟有 v-if 指令的元素并齐<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- v-model：把input的值和变量绑定了，实现了数据和视图的双向绑定 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;singer&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- v-bind：绑定元素的属性并执行相应的操作 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123;t1: isBig&#125;&quot;</span>&gt;</span>isBig 为 true 时，该元素class类名会变为 t1<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 上面v-bind可以简写 : --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123;t1: isBig&#125;&quot;</span>&gt;</span>isBig 为 true 时，该元素class类名会变为 t1<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- v-on：监听元素事件，并执行相应的操作 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>该元素绑定了点击事件<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 上面 v-on：可以简写 @ --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>该元素绑定了点击事件<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="javascript"><span class="xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span></span><br><span class="javascript"><span class="xml">            <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-attr">singer</span>: <span class="hljs-string">&#x27;周杰伦&#x27;</span>,</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-attr">list</span>:[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-attr">isShow</span>: <span class="hljs-literal">true</span>,</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-attr">isBig</span>: <span class="hljs-literal">true</span></span></span><br><span class="javascript"><span class="xml"></span></span><br><span class="javascript"><span class="xml">            &#125;</span></span><br><span class="javascript"><span class="xml">        &#125;,</span></span><br><span class="javascript"><span class="xml">        <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="javascript"><span class="xml">            change () &#123;</span></span><br><span class="javascript"><span class="xml">                <span class="hljs-comment">// ...</span></span></span><br><span class="javascript"><span class="xml">            &#125;</span></span><br><span class="javascript"><span class="xml">        &#125;</span></span><br><span class="javascript"><span class="xml">    &#125;</span></span><br><span class="javascript"><span class="xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>/&gt;</span> 和 <span class="hljs-tag">&lt;<span class="hljs-name">block</span>/&gt;</span></span><br><span class="xml">Uniapp 支持在 template 模板中嵌套 <span class="hljs-tag">&lt;<span class="hljs-name">template</span>/&gt;</span> 和 <span class="hljs-tag">&lt;<span class="hljs-name">block</span>/&gt;</span>，用来进行 列表渲染 和 条件渲染。</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>/&gt;</span> 和 <span class="hljs-tag">&lt;<span class="hljs-name">block</span>/&gt;</span> 并不是一个组件，它们仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</span><br><span class="xml">代码示例:</span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>test 为 true 时显示<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span></span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span>test 为 false 时显示<span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml"></span><br><span class="xml">    <span class="hljs-comment">&lt;!-- 列表渲染 --&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">block</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item,index) in list&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">view</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="xml"> - </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">index</span>&#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">view</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">block</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="xml"></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务的解决方案</title>
    <link href="/2021/01/11/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/01/11/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="分布式事务的解决方案"><a href="#分布式事务的解决方案" class="headerlink" title="分布式事务的解决方案"></a>分布式事务的解决方案</h2><ol><li><h3 id="MySQL-自带的两阶段提交-XA"><a href="#MySQL-自带的两阶段提交-XA" class="headerlink" title="MySQL 自带的两阶段提交/XA"></a>MySQL 自带的两阶段提交/XA</h3><p>顾名思义就是要分两步提交事务，多出来的事务为事务管理器。</p><p>大致的流程：</p><p>​ 第一阶段：事务管理器询问各个资源管理器是否都就绪，所有的参与者需要将自己本身事务是否执行成功的信息反馈给管理者</p><p>​ 第二阶段： 事务管理者根据资源的反馈，看是否需要提交或者回滚，</p><p>存在的问题：</p><ol><li>一旦事务管理器出问题了，整个系统都不可用了</li><li>数据可能会不一致，因为在阶段二中，需要反馈是否提供，如果反馈(commit)的消息，发送不完整，网络异常了之后，那么接收到会提交，未接收到的，不会提交，这个时候，数据就不一样了</li><li>因为是同步执行的，这时候如果事务未执行完成，其他的事务参与者，只能等待，对于并发来说，存在问题</li></ol></li><li><h3 id="可靠异步消息的最终一致性"><a href="#可靠异步消息的最终一致性" class="headerlink" title="可靠异步消息的最终一致性"></a>可靠异步消息的最终一致性</h3><p>借用一个消息中间件，来处理数据的更改，主要核心是异步处理。</p><ol><li>A 系统先向 mq 发送一条 prepare 消息，如果 prepare 消息发送失败，则直接取消操作</li><li>如果消息发送成功，则执行本地事务</li><li>如果本地事务执行成功，则想 mq 发送一条 confirm 消息，如果发送失败，则发送回滚消息</li><li>B 系统定期消费 mq 中的 confirm 消息，执行本地事务，并发送 ack 消息。如果 B 系统中的本地事务失败，会一直不断重试，如果是业务失败，会向 A 系统发起回滚请求</li></ol><p>该方案的其他应用场景也比较多，比如用户注册成功后发送邮件、电商系统用户下单支付成功给用户发送优惠券等，这些都需要保证最终一致性的场景</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式事务锁</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云敏感词安全接口PHP实现</title>
    <link href="/2020/12/01/%E9%98%BF%E9%87%8C%E4%BA%91%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%8E%A5%E5%8F%A3%E6%95%8F%E6%84%9F%E8%AF%8D/"/>
    <url>/2020/12/01/%E9%98%BF%E9%87%8C%E4%BA%91%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E6%8E%A5%E5%8F%A3%E6%95%8F%E6%84%9F%E8%AF%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="不啰嗦直接上代码"><a href="#不啰嗦直接上代码" class="headerlink" title="不啰嗦直接上代码"></a>不啰嗦直接上代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AliyunGreen</span></span><br><span class="hljs-class"></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$accessKeyId</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$accessKeySecret</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$url</span> = <span class="hljs-string">&#x27;https://green.%s.aliyuncs.com%s&#x27;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$api</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-variable">$signatureNonce</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">__construct</span>(<span class="hljs-params"><span class="hljs-variable">$accessKeyId</span>, <span class="hljs-variable">$accessKeySecret</span>, <span class="hljs-variable">$area</span>, <span class="hljs-variable">$api</span>, <span class="hljs-variable">$signatureNonce</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">$this</span>-&gt;accessKeyId = <span class="hljs-variable">$accessKeyId</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;accessKeySecret = <span class="hljs-variable">$accessKeySecret</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;api = <span class="hljs-variable">$api</span>;<br>        <span class="hljs-keyword">$this</span>-&gt;url = \sprintf(<span class="hljs-keyword">$this</span>-&gt;url, <span class="hljs-variable">$area</span>, <span class="hljs-variable">$api</span>);<br>        <span class="hljs-keyword">$this</span>-&gt;signatureNonce = <span class="hljs-variable">$signatureNonce</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $body</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $clientInfo</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> mixed</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setQueryUrl</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$body</span>, <span class="hljs-keyword">string</span> <span class="hljs-variable">$clientInfo</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$headers</span> = <span class="hljs-keyword">$this</span>-&gt;setHeader(<span class="hljs-variable">$body</span>);<br><br>        <span class="hljs-variable">$str</span> = <span class="hljs-string">&quot;POST&quot;</span> . PHP_EOL;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$headers</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$k</span> =&gt; <span class="hljs-variable">$v</span>) &#123;<br>            <span class="hljs-keyword">if</span> (strpos(<span class="hljs-variable">$k</span>, <span class="hljs-string">&#x27;x-acs&#x27;</span>) === <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-variable">$str</span> .= <span class="hljs-variable">$k</span> . <span class="hljs-string">&#x27;:&#x27;</span> . <span class="hljs-variable">$v</span> . PHP_EOL;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-variable">$str</span> .= <span class="hljs-variable">$v</span> . PHP_EOL;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$clientInfo</span>) &amp;&amp; <span class="hljs-variable">$clientInfo</span> != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>            <span class="hljs-variable">$str</span> .= <span class="hljs-string">&quot;<span class="hljs-subst">$this</span>-&gt;api?clientInfo=&quot;</span> . <span class="hljs-variable">$clientInfo</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-variable">$str</span> .= <span class="hljs-keyword">$this</span>-&gt;api;<br>        &#125;<br><br>        <span class="hljs-variable">$signature</span> = base64_encode(hash_hmac(<span class="hljs-string">&quot;sha1&quot;</span>, <span class="hljs-variable">$str</span>, <span class="hljs-keyword">$this</span>-&gt;accessKeySecret, <span class="hljs-literal">true</span>));<br>        <span class="hljs-variable">$Authorization</span> = [<span class="hljs-string">&#x27;Authorization&#x27;</span> =&gt; <span class="hljs-string">&quot;acs <span class="hljs-subst">$this</span>-&gt;accessKeyId:<span class="hljs-subst">$signature</span>&quot;</span>];<br><br>        <span class="hljs-variable">$httpHeader</span> = array_merge(<span class="hljs-variable">$headers</span>, <span class="hljs-variable">$Authorization</span>);<br>        <span class="hljs-variable">$queryHeader</span> = [];<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-variable">$httpHeader</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$k</span> =&gt; <span class="hljs-variable">$v</span>) &#123;<br>            <span class="hljs-variable">$queryHeader</span>[] = <span class="hljs-variable">$k</span> . <span class="hljs-string">&#x27;:&#x27;</span> . <span class="hljs-variable">$v</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$clientInfo</span>) &amp;&amp; <span class="hljs-variable">$clientInfo</span> != <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>            <span class="hljs-keyword">$this</span>-&gt;url = <span class="hljs-keyword">$this</span>-&gt;url . <span class="hljs-string">&#x27;?clientInfo=&#x27;</span> . urlencode(<span class="hljs-variable">$clientInfo</span>);<br>        &#125;<br><br>        <span class="hljs-variable">$res</span> = <span class="hljs-keyword">$this</span>-&gt;curl(<span class="hljs-keyword">$this</span>-&gt;url, <span class="hljs-literal">true</span>, <span class="hljs-variable">$body</span>, <span class="hljs-variable">$queryHeader</span>);<br>        <span class="hljs-keyword">return</span> json_decode(<span class="hljs-variable">$res</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $body</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> array</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setHeader</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$body</span></span>): <span class="hljs-title">array</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$headers</span> = [<br>            <span class="hljs-string">&#x27;Accept&#x27;</span> =&gt; <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>            <span class="hljs-string">&#x27;Content-MD5&#x27;</span> =&gt; base64_encode(md5(<span class="hljs-variable">$body</span>, <span class="hljs-number">1</span>)),<br>            <span class="hljs-string">&#x27;Content-Type&#x27;</span> =&gt; <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>            <span class="hljs-string">&#x27;Date&#x27;</span> =&gt; gmdate(<span class="hljs-string">&#x27;D, d M Y H:i:s T&#x27;</span>, time()), <span class="hljs-comment">//&#x27;Tue, 17 Jan 2017 10:16:36 GMT&#x27;,注意时区</span><br>            <span class="hljs-string">&#x27;x-acs-version&#x27;</span> =&gt; <span class="hljs-string">&#x27;2018-05-09&#x27;</span>,<br>            <span class="hljs-string">&#x27;x-acs-signature-nonce&#x27;</span> =&gt; <span class="hljs-keyword">$this</span>-&gt;signatureNonce == <span class="hljs-string">&#x27;&#x27;</span> ? <span class="hljs-keyword">$this</span>-&gt;getSignatureNonce(<span class="hljs-number">10</span>) : <span class="hljs-keyword">$this</span>-&gt;signatureNonce,<br>            <span class="hljs-string">&#x27;x-acs-signature-version&#x27;</span> =&gt; <span class="hljs-string">&#x27;1.0&#x27;</span>,<br>            <span class="hljs-string">&#x27;x-acs-signature-method&#x27;</span> =&gt; <span class="hljs-string">&#x27;HMAC-SHA1&#x27;</span>,<br>        ];<br>        ksort(<span class="hljs-variable">$headers</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$headers</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> string $url</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bool $isPost</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> $arr</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> array $header</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> bool|string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curl</span>(<span class="hljs-params"><span class="hljs-keyword">string</span> <span class="hljs-variable">$url</span>, <span class="hljs-keyword">bool</span> <span class="hljs-variable">$isPost</span>, <span class="hljs-variable">$arr</span>, <span class="hljs-keyword">array</span> <span class="hljs-variable">$header</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-variable">$ch</span> = curl_init();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$ch</span> === <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(<span class="hljs-string">&#x27;failed to initialize&#x27;</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (stripos(<span class="hljs-variable">$url</span>, <span class="hljs-string">&quot;https://&quot;</span>) !== <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-comment">//关闭证书</span><br>                curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_SSL_VERIFYPEER, <span class="hljs-literal">false</span>);<br>                curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_SSL_VERIFYHOST, <span class="hljs-literal">false</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$header</span>)) &#123;<br>                curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_HTTPHEADER, <span class="hljs-variable">$header</span>);<br>                curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_HEADER, <span class="hljs-number">0</span>); <span class="hljs-comment">//返回response头部信息</span><br>            &#125;<br>            curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_URL, <span class="hljs-variable">$url</span>);<br>            curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_RETURNTRANSFER, <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//post方式</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">empty</span>(<span class="hljs-variable">$isPost</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (is_array(<span class="hljs-variable">$arr</span>)) &#123;<br>                    <span class="hljs-variable">$content</span> = http_build_query(<span class="hljs-variable">$arr</span>); <span class="hljs-comment">//入参内容</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-variable">$content</span> = <span class="hljs-variable">$arr</span>;<br>                &#125;<br>                curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_POST, <span class="hljs-literal">true</span>);<br>                curl_setopt(<span class="hljs-variable">$ch</span>, CURLOPT_POSTFIELDS, <span class="hljs-variable">$content</span>); <span class="hljs-comment">//所传参</span><br>            &#125;<br><br>            <span class="hljs-variable">$sContent</span> = curl_exec(<span class="hljs-variable">$ch</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">$sContent</span> === <span class="hljs-literal">false</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>(curl_error(<span class="hljs-variable">$ch</span>), curl_errno(<span class="hljs-variable">$ch</span>));<br>            &#125;<br>            <span class="hljs-variable">$aStatus</span> = curl_getinfo(<span class="hljs-variable">$ch</span>);<br>            curl_close(<span class="hljs-variable">$ch</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">$sContent</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">Exception</span> <span class="hljs-variable">$e</span>) &#123;<br>            trigger_error(sprintf(<br>                <span class="hljs-string">&#x27;Curl failed with error #%d: %s&#x27;</span>,<br>                <span class="hljs-variable">$e</span>-&gt;getCode(), <span class="hljs-variable">$e</span>-&gt;getMessage()),<br>                E_USER_ERROR);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> int $length</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> string</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSignatureNonce</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> <span class="hljs-variable">$length</span></span>): <span class="hljs-title">string</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$str</span> = <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span>;<br>        <span class="hljs-variable">$len</span> = strlen(<span class="hljs-variable">$str</span>) - <span class="hljs-number">1</span>;<br>        <span class="hljs-variable">$randstr</span> = <span class="hljs-string">&#x27;&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span> = <span class="hljs-number">0</span>; <span class="hljs-variable">$i</span> &lt; <span class="hljs-variable">$length</span>; <span class="hljs-variable">$i</span>++) &#123;<br>            <span class="hljs-variable">$num</span> = mt_rand(<span class="hljs-number">0</span>, <span class="hljs-variable">$len</span>);<br>            <span class="hljs-variable">$randstr</span> .= <span class="hljs-variable">$str</span>[<span class="hljs-variable">$num</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">$randstr</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 文本审核</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">textScan</span>(<span class="hljs-params"><span class="hljs-variable">$content</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$tasks</span> = <span class="hljs-keyword">$this</span>-&gt;setQueryUrl(<span class="hljs-variable">$content</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>        print_r(<span class="hljs-variable">$tasks</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 图片审核</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">imageScan</span>(<span class="hljs-params"><span class="hljs-variable">$content</span></span>)</span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-variable">$tasks</span> = <span class="hljs-keyword">$this</span>-&gt;setQueryUrl(<span class="hljs-variable">$content</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>        print_r(<span class="hljs-variable">$tasks</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scilab"><span class="hljs-comment">// 使用方式</span><br>$text = new AliyunGreen(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;secret&#x27;</span>, <span class="hljs-string">&#x27;cn-beijing&#x27;</span>, <span class="hljs-string">&#x27;/green/text/scan&#x27;</span>,<br>    <span class="hljs-string">&#x27;&#x27;</span>);<br>$body = <span class="hljs-string">&#x27;&#123;&quot;</span>scenes<span class="hljs-string">&quot;: [&quot;</span>antispam<span class="hljs-string">&quot;],&quot;</span>tasks<span class="hljs-string">&quot;: [&#123;&quot;</span>dataId<span class="hljs-string">&quot;: &quot;</span>cfd33235<span class="hljs-number">-71</span>a4<span class="hljs-number">-468</span>b<span class="hljs-number">-8137</span>-a5ffe323a7e8<span class="hljs-string">&quot;,&quot;</span>content<span class="hljs-string">&quot;: &quot;</span>本校小额贷款，安全、快捷、方便、无抵押，随机随贷，当天放款，上门服务。<span class="hljs-string">&quot;&#125;]&#125;&#x27;</span>;<br>print_r($text-&gt;textScan($body));<br><br>$image = new AliyunGreen(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;secret&#x27;</span>, <span class="hljs-string">&#x27;cn-shenzhen&#x27;</span>, <span class="hljs-string">&#x27;/green/image/scan&#x27;</span>,<br>    <span class="hljs-string">&#x27;&#x27;</span>);<br>$body = <span class="hljs-string">&#x27;&#123;&quot;</span>scenes<span class="hljs-string">&quot;:[&quot;</span>porn<span class="hljs-string">&quot;],&quot;</span>tasks<span class="hljs-string">&quot;:[&#123;&quot;</span>dataId<span class="hljs-string">&quot;:&quot;</span>test2NInmO$tAON6qYUrtCRgLo<span class="hljs-number">-1</span>mwxdi<span class="hljs-string">&quot;,&quot;</span>url<span class="hljs-string">&quot;:&quot;</span>https:<span class="hljs-comment">//img.alicdn.com/tfs/TB1urBOQFXXXXbMXFXXXXXXXXXX-1442-257.png&quot;&#125;]&#125;&#x27;;</span><br>print_r($image-&gt;imageScan($body));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP面试题总结</title>
    <link href="/2020/11/23/%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2020/11/23/%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-laravel-生命周期"><a href="#1-laravel-生命周期" class="headerlink" title="1. laravel 生命周期"></a>1. laravel 生命周期</h2><p>文件先自动加载 composer 包需要的类，包扩所有你自己的 composer 依赖包，<br>生成容器 Cantainer 并注册相关的一些核心组件和实例，是从 bootstrap/app.php 脚本获取 Laravel 应用实例，<br>处理请求一般都是 http 请求，检测 booststrap 环境，加载里面的一些配置，注册像是系统的环境配置，日志配置，异常处理配置，服务器的容器，门面，服务提供者<br>相应的配置都加载完毕了，就会转到路由，路由会先处理全局中间件，看看是否允许访问，是不是有一异常，然后再去遍历匹配你输入的路由地址，找到符合的进行访问再看你的控制器是否有中间件的一些限制，再进行返回</p><h2 id="2-nginx-负载均衡-方式优缺点"><a href="#2-nginx-负载均衡-方式优缺点" class="headerlink" title="2. nginx 负载均衡 方式优缺点"></a>2. nginx 负载均衡 方式优缺点</h2><p>upstream nginx 对网络的稳定性比较小，配置安装起来比较简单，也提供了一些基础的负载均衡的访问方式，像是轮询、权重值轮询，ip_hash 的方式每个请求访问的 ip 通过 hash 之后的结果进行分配访问<br>支持的协议比较少</p><h2 id="3-mysql-innodb-Mysiam-引擎-区别-优劣"><a href="#3-mysql-innodb-Mysiam-引擎-区别-优劣" class="headerlink" title="3. mysql innodb Mysiam 引擎 区别 优劣"></a>3. mysql innodb Mysiam 引擎 区别 优劣</h2><h2 id="4-索引相关"><a href="#4-索引相关" class="headerlink" title="4. 索引相关"></a>4. 索引相关</h2><h2 id="5-swoole-用过吗了解多少，go-呢？"><a href="#5-swoole-用过吗了解多少，go-呢？" class="headerlink" title="5. swoole 用过吗了解多少，go 呢？"></a>5. swoole 用过吗了解多少，go 呢？</h2><h2 id="6-项目用多少台服务器"><a href="#6-项目用多少台服务器" class="headerlink" title="6. 项目用多少台服务器"></a>6. 项目用多少台服务器</h2><h2 id="7-大文件-excel-导出"><a href="#7-大文件-excel-导出" class="headerlink" title="7. 大文件 excel 导出"></a>7. 大文件 excel 导出</h2><p>ob_flush</p><h2 id="8-主从延迟解决方案-半同步复制"><a href="#8-主从延迟解决方案-半同步复制" class="headerlink" title="8. 主从延迟解决方案 半同步复制"></a>8. 主从延迟解决方案 半同步复制</h2><p>主库需要提交事务、更新存储引擎中的数据、把 Binlog 写到磁盘上、给客户端返回响应、把 Binlog 复制到所有从库上、每个从库需要把复制过来的 Binlog 写到暂存日志中、回放这个 Binlog、更新存储引擎中的数据、给主库返回复制成功的响应。<br>异步复制时，主库提交事务之后，就会给客户端返回响应；而同步复制时，主库在提交事务的时候，会等待数据复制到所有从库之后，再给客户端返回响应。<br>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。sql_thread 读取中转日志，解析出日志里的命令，并执行。</p><h2 id="9-Oauth2-0-协议"><a href="#9-Oauth2-0-协议" class="headerlink" title="9. Oauth2.0 协议"></a>9. Oauth2.0 协议</h2><p>关于框架，协议，代理，反代理，设计模式，版本管理</p>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP一次面试的面试题</title>
    <link href="/2020/08/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2020/08/27/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">blah blah blah</blockquote># 面试题汇总<h4 id="1、秒杀流程的清楚？"><a href="#1、秒杀流程的清楚？" class="headerlink" title="1、秒杀流程的清楚？"></a>1、秒杀流程的清楚？</h4><pre><code>使用异步处理的思路来做的秒杀活动，我们先接受秒杀时间段内的所有订单请求，单我们没有实际进行秒杀成功还是失败的结果，而是放到了redis 队列里面，给了用户一个排队等待的结果的页面，当然用户也可以退出这个页面去待支付订单 页面里面去完成支付。然后我们从队列里面获取订单的请求，然后再交给生成订单的业务，进行生成订单，然后再把秒杀结果告诉用户，用户进行支付成功之后，扣减库存。</code></pre><h4 id="2、laravel-的依赖注入？"><a href="#2、laravel-的依赖注入？" class="headerlink" title="2、laravel 的依赖注入？"></a>2、laravel 的依赖注入？</h4><pre><code>  由容器动态的将某个依赖关系注入到组件中，他的目的是为了提升组件使用的频率，来灵活使用它。说白了就是一个对象依赖于另一个对象的技术，他可以通过构造函数直接注入，也可通过接口的方式注入</code></pre><h4 id="3、Laravel-中的-app-类实现单利模式？"><a href="#3、Laravel-中的-app-类实现单利模式？" class="headerlink" title="3、Laravel 中的 app 类实现单利模式？"></a>3、Laravel 中的 app 类实现单利模式？</h4><h4 id="4、left-join-效率低？"><a href="#4、left-join-效率低？" class="headerlink" title="4、left join 效率低？"></a>4、left join 效率低？</h4><pre><code>它把两个表中的你要查询的数据组成一张新的表，产生临时表，所有查询</code></pre><p>起来比较慢。如果使用 join 语句的话，需要让小表做驱动表。但条件是能使用到驱动表中的索引。</p><h4 id="5、订单回收问题。"><a href="#5、订单回收问题。" class="headerlink" title="5、订单回收问题。"></a>5、订单回收问题。</h4><pre><code>如果没有使用缓存的话，就写一个定时任务，定期去回收未支付的订单。如果有使用缓存的话，放到队列里面，加一个过期的时间。    也可以使用消息队列中间件</code></pre><h4 id="6、埋点上报怎么处理？"><a href="#6、埋点上报怎么处理？" class="headerlink" title="6、埋点上报怎么处理？"></a>6、埋点上报怎么处理？</h4><pre><code>如果前端埋点的事件较多，或者说网页内部交互频繁，可以通过本地存储的方式先缓存上报信息，然后定期上报。然后后台再进行处理，如果前端实时上报到后端的话，那就通过消费队列的方式定期去处理上报数据。</code></pre><h4 id="7、说一下缓存穿透和缓存雪崩？"><a href="#7、说一下缓存穿透和缓存雪崩？" class="headerlink" title="7、说一下缓存穿透和缓存雪崩？"></a>7、说一下缓存穿透和缓存雪崩？</h4><pre><code>如果缓存失效了或者查出来的值是空的，不是立即去数据库进行查询，而是使用缓存本身成功操作的返回值进行返回，并利用redis的互斥锁(mutex key)的方式重新把数据缓存起来。雪崩的话，就像解决穿透一样加互斥锁，建立备份的缓存，有一份缓存不设置缓存失效时间，如果A没读到缓存就去读取B，并更新A和B的缓存。</code></pre><h4 id="8、在工作中使用-Git-的基本流程？"><a href="#8、在工作中使用-Git-的基本流程？" class="headerlink" title="8、在工作中使用 Git 的基本流程？"></a>8、在工作中使用 Git 的基本流程？</h4><pre><code>提交 git add 、写更新内容 git commit -m 、查不同 git diff 、建立分支 git branch 、切换分支 git checkout、分支合并：git merge、显示本地仓库的所有分支：git branch、</code></pre><h4 id="9、简单说下非对称加密？"><a href="#9、简单说下非对称加密？" class="headerlink" title="9、简单说下非对称加密？"></a>9、简单说下非对称加密？</h4><pre><code>非对称加密是有公钥和私钥，他们是成对使用的，公钥是可以给外人看的，私钥要自己保护好。用公钥进行加密而用私钥进行解密。同一队公钥和私钥。</code></pre><h4 id="10、你们是怎么把-mysql-的数据同步到-es-上去的？"><a href="#10、你们是怎么把-mysql-的数据同步到-es-上去的？" class="headerlink" title="10、你们是怎么把 mysql 的数据同步到 es 上去的？"></a>10、你们是怎么把 mysql 的数据同步到 es 上去的？</h4><pre><code>最方便的方式可以同时更新，写入数据库的时候，同时写一个队列模块，通过队列的方式同步更新到 es我们就简单的使用 mysql 的binlog （ROW模式）日志进行同步的。或者使用mysqldump工具进行同步。或者使用第三方的工具</code></pre><h4 id="11、简单说下你怎么实现-mysql-主从"><a href="#11、简单说下你怎么实现-mysql-主从" class="headerlink" title="11、简单说下你怎么实现 mysql 主从"></a>11、简单说下你怎么实现 mysql 主从</h4><pre><code>因为mysql binlog的强大，我们把从库和主库维持一个长链接，从你设置的一些访问主库的Ip啊端口啊，用户名密码啊binlog读取的位置啊和主库进行交互，主库验证成功了之后，会从自己本地读取binlog 然后发送给从库。当然你也可以使用第三方的工具比如 mycat 去实现。</code></pre><h4 id="12、说下你理解的-php-fpm。"><a href="#12、说下你理解的-php-fpm。" class="headerlink" title="12、说下你理解的 php-fpm。"></a>12、说下你理解的 php-fpm。</h4><pre><code>php-FPM 是一个PHP进程管理器 ，包含master 和worker 两种进程,首先它会启动一个 master 进程有且有一个，只负责监听端口，接收来自服务器的请求，然后会有多个 worker 进程具体多少根据你的配置，当请求过来的时候，master 会传递给一个 worker，然后立即接受下一个请求，当worker不够用的时候会直接返回502的错误。worker 请求超时的话会返回504，当然 php-fpm 也可以配置为动态模式，这样子的话，worker 的进程数量就是按照需求去启动的了。</code></pre><h4 id="13、进程线程协程"><a href="#13、进程线程协程" class="headerlink" title="13、进程线程协程"></a>13、进程线程协程</h4><pre><code>进程是通过CPU运行的，一个进程挂了不影响另一个，线程属于进程，但是一个线程挂了不但影响其他的线程，还会把整个进程搞挂。协程是属于线程的。协程实在线程里面跑的，它没有上下文的切换，它之间的调度切换是通过程序员代码实现的，所以它特别灵活，因此也叫用户态的线程。</code></pre><h4 id="14、php-关联数组底层结构"><a href="#14、php-关联数组底层结构" class="headerlink" title="14、php 关联数组底层结构"></a>14、php 关联数组底层结构</h4><pre><code>在PHP中, 数组是用一种HASH结构(HashTable)来实现的。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>PHP 面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的锁来缓解并发请求</title>
    <link href="/2020/07/11/Redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%BC%93%E8%A7%A3%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/07/11/Redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%BC%93%E8%A7%A3%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-锁-缓解并发"><a href="#Redis-锁-缓解并发" class="headerlink" title="Redis 锁 缓解并发"></a>Redis 锁 缓解并发</h2><ol><li><h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>Redis 锁主要利用 Redis 的 setnx 命令实现</p><ul><li>加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。</li></ul><ul><li>解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。</li><li>锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。</li></ul><p>代码编写：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">if</span> (Redis::setnx(<span class="hljs-string">&quot;my:lock&quot;</span>, <span class="hljs-number">1</span>)) &#123;<br>    Redis::expire(<span class="hljs-string">&quot;my:lock&quot;</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">// ... do something</span><br><br>    Redis::del(<span class="hljs-string">&quot;my:lock&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>官方推荐的写法(建议用这种写法)：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br> &#123;<br>    <span class="hljs-keyword">if</span>(redisLock(<span class="hljs-variable">$token</span>))<br>    &#123;<br>         <span class="hljs-comment">//业务内容</span><br>         unlock(<span class="hljs-variable">$token</span>);<br>         <span class="hljs-keyword">break</span>;<br>    &#125;<br> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">redisLock</span>(<span class="hljs-params"><span class="hljs-variable">$token</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">return</span> Redis::set(<span class="hljs-string">&quot;my:lock&quot;</span>, <span class="hljs-variable">$token</span>, <span class="hljs-string">&quot;ex&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;nx&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unlock</span>(<span class="hljs-params"><span class="hljs-variable">$token</span></span>)</span><br><span class="hljs-function"> </span>&#123;<br>    <span class="hljs-variable">$script</span> = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;,KEYS[1]) == ARGV[1]</span><br><span class="hljs-string">    then return redis.call(&#x27;del&#x27;,KEYS[1])</span><br><span class="hljs-string">    else return 0</span><br><span class="hljs-string">    end&quot;</span>;<br>    <span class="hljs-keyword">return</span> Redis::eval(<span class="hljs-variable">$script</span>,<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;my:lock&#x27;</span>,<span class="hljs-variable">$token</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里的 token 是一个随机数，当 lock 的时候，往 redis 的 my:lock 中存的是这个 token，unlock 的时候，先 get 一下 lock 中的 token，如果和我要删除的 token 是一致的，说明这个锁是之前我 set 的，否则的话，说明这个锁已经过期，是别人 set 的，我就不应该对它进行任何操作。</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>Redis</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红楼梦中的诗句记录</title>
    <link href="/2020/06/15/%E7%BA%A2%E6%A5%BC%E6%A2%A6/"/>
    <url>/2020/06/15/%E7%BA%A2%E6%A5%BC%E6%A2%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="红楼梦"><a href="#红楼梦" class="headerlink" title="红楼梦"></a>红楼梦</h1><p>满纸荒唐言，一把辛酸泪。<br>都云作者痴，谁解其中味！</p><p>惯养娇生笑你痴，菱花空对雪澌澌。<br>好防佳节元宵后，便是烟消火灭时。</p><p>未卜三生愿，频添一段愁。<br>闷来时敛额，行去几回头。<br>自顾风前影，谁堪月下俦？<br>蟾光如有意，先上玉人楼。</p><p>时逢三五便团圆，满把晴光护玉栏。<br>天上一轮才捧出，人间万姓仰头看。</p><p>一局输赢料不真，香销茶尽尚逡巡。<br>欲知目下兴衰兆，须问旁观冷眼人。</p><p>一场幽梦同谁近，千古情人独我痴。</p><p>得意浓时易接济，受恩深处胜亲朋。</p><p>黄花满地，白柳横坡。<br>小桥通若耶之溪，曲径接天台之路。<br>石中清流激湍，篱落飘香；树头红叶翩翻，疏林如画。<br>西风乍紧，初罢莺啼；暖日当暄，又添蛩语。<br>遥望东南，建几处依山之榭；纵观西北，结三间临水之轩。<br>笙簧盈耳，别有幽情；罗绮穿林，倍添韵致</p><p>无端弄笔是何人？作践南华庄子因。<br>不悔自己无见识，却将丑语怪他人！</p><p>淑女从来多抱怨，娇妻自古便含酸。</p><p>春夜即事<br>霞绡云幄任铺陈，隔巷蟆更听未真。枕上轻寒窗外雨，眼前春色梦中人。盈盈烛泪因谁泣，点点花愁为我嗔。自是小鬟娇懒惯，拥衾不耐笑言频。<br>夏夜即事<br>倦绣佳人幽梦长，金笼鹦鹉唤茶汤。窗明麝月开宫镜，室霭檀云品御香。琥珀杯倾荷露滑，玻璃槛纳柳风凉。水亭处处齐纨动，帘卷朱楼罢晚妆。<br>秋夜即事<br>绛芸轩里绝喧哗，桂魄流光浸茜纱。苔锁石纹容睡鹤，井飘桐露湿栖鸦。抱衾婢至舒金凤，倚槛人归落翠花。静夜不眠因酒渴，沉烟重拨索烹茶。<br>冬夜即事<br>梅魂竹梦已三更，锦罽衾[1]睡未成。松影一庭惟见鹤，梨花满地不闻莺。女儿翠袖诗怀冷，公子金貂酒力轻。却喜侍儿知试茗，扫将新雪及时烹。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 缓存策略</title>
    <link href="/2020/05/21/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/2020/05/21/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h1><h4 id="数据脏读脏写-不一致的解决情况"><a href="#数据脏读脏写-不一致的解决情况" class="headerlink" title="数据脏读脏写 不一致的解决情况"></a>数据脏读脏写 不一致的解决情况</h4><p>其实，我们可以在更新数据时不更新缓存，而是删除缓存中的数据，在读取数据时，发现缓存中没了数据之后，再从数据库中读取数据，更新到缓存中。<br>这个策略就是我们使用缓存最常见的策略，Cache Aside 策略（也叫旁路缓存策略），这个策略数据以数据库中的数据为准，缓存中的数据是按需加载的。它可以分为读策略和写策略，其中读策略的步骤是：<br>从缓存中读取数据；<br>如果缓存命中，则直接返回数据；<br>如果缓存不命中，则从数据库中查询数据；<br>查询到数据后，将数据写入到缓存中，并且返回给用户。<br>写策略的步骤是：<br>更新数据库中的记录；<br>删除缓存记录。</p><p>Cache Aside 存在的最大的问题是当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。如果你的业务对缓存命中率有严格的要求，那么可以考虑两种解决方案：</p><ol><li>一种做法是在更新数据时也更新缓存，只是在更新缓存前先加一个分布式锁，因为这样在同一时间只允许一个线程更新缓存，就不会产生并发问题了。当然这么做对于写入的性能会有一些影响；</li><li>另一种做法同样也是在更新数据时更新缓存，只是给缓存加一个较短的过期时间，这样即使出现缓存不一致的情况，缓存的数据也会很快过期，对业务的影响也是可以接受。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac 安装 RabbitMQ</title>
    <link href="/2020/03/24/RabbitMQ%20(httplocalhost15672)/"/>
    <url>/2020/03/24/RabbitMQ%20(httplocalhost15672)/</url>
    
    <content type="html"><![CDATA[<h2 id="安装-RabbitMQ-http-localhost-15672"><a href="#安装-RabbitMQ-http-localhost-15672" class="headerlink" title="安装 RabbitMQ (http://localhost:15672)"></a>安装 RabbitMQ (<a href="http://localhost:15672/">http://localhost:15672</a>)</h2><p>访问地址是：<a href="http://localhost:15672/">RabbitMQ Management</a><br>Z 帐号密码： guest</p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>brew update</p><h3 id="执行安装"><a href="#执行安装" class="headerlink" title="执行安装"></a>执行安装</h3><p>brew install rabbitmq<br>brew install rabbitmq-c</p><h3 id="执行安装-php-扩展"><a href="#执行安装-php-扩展" class="headerlink" title="执行安装 php 扩展"></a>执行安装 php 扩展</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/pdezwart/</span>php-amqp.git<br>phpize<br>.<span class="hljs-regexp">/configure —with-librabbitmq-dir=/u</span>sr<span class="hljs-regexp">/local/</span>Cellar<span class="hljs-regexp">/rabbitmq-c/</span><span class="hljs-number">0.10</span>.<span class="hljs-number">0</span><br>make &amp;&amp; make install<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 学习记录</title>
    <link href="/2020/03/23/MySQL%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/23/MySQL%20%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-记录"><a href="#MySQL-记录" class="headerlink" title="MySQL 记录"></a>MySQL 记录</h2><h3 id="1-1-事务的特性（ACID）"><a href="#1-1-事务的特性（ACID）" class="headerlink" title="1.1 事务的特性（ACID）"></a>1.1 事务的特性（ACID）</h3><ol><li>事务要求 ACID 的特性，即：原原子子性性、、一一致致性性、、隔隔离离性性、、持持久久性性。 </li><li>所谓原子性，是指整个数据库的每个事务都是不可分割的单位。只有事务中的所有 SQL 语句都执行成功，才算整个事务成功，事务才会被提交。如果事务<br>中任何一个 SQL 语句执行失败，整个事务都应该被回滚。 </li><li>所谓一致性，是指将数据库从一种一致性状态转换为下一种一致性状态。不允许数据库中的数据出现新老数据都有的情况，要么都是老数据，要么都是新数<br>据。用更书面化的表达就是：数据的完整性约束没有被破坏。 </li><li>所谓隔离性，是指一个事务的影响在该事务提交前对其他事务都不可见，它通过锁机制来实现。 </li><li>所谓持久性，是指事务一旦被提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。 </li></ol><h3 id="1-2-事务的语法"><a href="#1-2-事务的语法" class="headerlink" title="1.2 事务的语法"></a>1.2 事务的语法</h3><ol><li>在 MySQL 命令行的默认设置下，事务是自动提交的，即执行了SQL 语句之后会马上执行 commit 操作，我们可以设置 set autocommit=0 来禁用当前回话<br>的自动提交。 </li><li>还可以用 begin 、start transaction 来显式的开始一个事务。 </li><li>Commit 在默认设置下是等价于 commit work 的，表示提交事务。 </li><li>rollback 在默认设置下等价于 rollback work，表示事务回滚。 </li><li>savepoint xxx 表示定义一个保存点，在一个事务中可以有多个保存点。 </li><li>Release savepoint xxx 表示删除一个保存点，当没有该保存点的时候执行该语句，会抛出一个异常。 </li><li>rollback to [savepoint] xxx 表示回滚到某个保存点。 </li></ol><h3 id="1-3-事务的生命周期"><a href="#1-3-事务的生命周期" class="headerlink" title="1.3 事务的生命周期"></a>1.3 事务的生命周期</h3><ol><li>开启事务，开始执行此事务</li><li>创建日志文件</li><li>执行业务逻辑 commit （根据实际的sql写入日志文件，但并没有运行sql语句）</li><li>刷新日志文件</li><li>最终执行sql环节，数据写入磁盘</li><li>写入 CKP 日志文件，数据的校验保证一致性</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 实现简单的限流</title>
    <link href="/2020/02/11/redis%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81/"/>
    <url>/2020/02/11/redis%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E9%99%90%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2 id="利用-Redis-有序集合实现，并用管道加速。"><a href="#利用-Redis-有序集合实现，并用管道加速。" class="headerlink" title="利用 Redis 有序集合实现，并用管道加速。"></a>利用 Redis 有序集合实现，并用管道加速。</h2><h3 id="假设-period-秒内，一个用户只能访问-maxCount-次。用户-ID-作为-key，毫秒时间戳作为-score-和-value。"><a href="#假设-period-秒内，一个用户只能访问-maxCount-次。用户-ID-作为-key，毫秒时间戳作为-score-和-value。" class="headerlink" title="假设 $period 秒内，一个用户只能访问 $maxCount 次。用户 ID 作为 key，毫秒时间戳作为 score 和 value。"></a>假设 $period 秒内，一个用户只能访问 $maxCount 次。用户 ID 作为 key，毫秒时间戳作为 score 和 value。</h3><p>一个请求进入，</p><ul><li>加入有序集合——zadd</li><li>移除时间窗口之前的行为记录，剩下的都是时间窗口内的——zremrangebyscore</li><li>更新过期时间——expire</li><li>获取窗口内的元素数量——zcard</li><li>判断窗口内元素数量是否大于最大请求限制数（maxCount），若大于等于则拒绝请求，若小于则接受请求。</li></ul><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isActionAllowed</span>(<span class="hljs-params"><span class="hljs-variable">$userId</span>, <span class="hljs-variable">$action</span>, <span class="hljs-variable">$period</span>, <span class="hljs-variable">$maxCount</span></span>)</span><br><span class="hljs-function"></span>&#123;<br>     <span class="hljs-variable">$redis</span> = <span class="hljs-keyword">new</span> Redis();<br>     <span class="hljs-variable">$redis</span>-&gt;connect(<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">6379</span>);<br>     <span class="hljs-variable">$key</span> = sprintf(<span class="hljs-string">&#x27;hist:%s:%s&#x27;</span>, <span class="hljs-variable">$userId</span>, <span class="hljs-variable">$action</span>);<br>     <span class="hljs-variable">$now</span> = msectime();   <span class="hljs-comment"># 毫秒时间戳</span><br><br>     <span class="hljs-variable">$pipe</span>=<span class="hljs-variable">$redis</span>-&gt;multi(Redis::PIPELINE); <span class="hljs-comment">//使用管道提升性能</span><br>     <span class="hljs-variable">$pipe</span>-&gt;zadd(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$now</span>, <span class="hljs-variable">$now</span>); <span class="hljs-comment">//value 和 score 都使用毫秒时间戳</span><br>     <span class="hljs-variable">$pipe</span>-&gt;zremrangebyscore(<span class="hljs-variable">$key</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">$now</span> - <span class="hljs-variable">$period</span> * <span class="hljs-number">1000</span>); <span class="hljs-comment">//移除时间窗口之前的行为记录，剩下的都是时间窗口内的</span><br>     <span class="hljs-variable">$pipe</span>-&gt;zcard(<span class="hljs-variable">$key</span>);  <span class="hljs-comment">//获取窗口内的行为数量</span><br>     <span class="hljs-variable">$pipe</span>-&gt;expire(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$period</span>  + <span class="hljs-number">1</span>);  <span class="hljs-comment">//多加一秒过期时间</span><br>     <span class="hljs-variable">$replies</span> = <span class="hljs-variable">$pipe</span>-&gt;exec();<br>     <span class="hljs-keyword">return</span> <span class="hljs-variable">$replies</span>[<span class="hljs-number">2</span>] &lt;= <span class="hljs-variable">$maxCount</span>;<br> &#125;<br><br> <span class="hljs-comment">//返回当前的毫秒时间戳</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">msectime</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-keyword">list</span>(<span class="hljs-variable">$msec</span>, <span class="hljs-variable">$sec</span>) = explode(<span class="hljs-string">&#x27; &#x27;</span>, microtime());<br>     <span class="hljs-variable">$msectime</span> = (<span class="hljs-keyword">float</span>)sprintf(<span class="hljs-string">&#x27;%.0f&#x27;</span>, (floatval(<span class="hljs-variable">$msec</span>) + floatval(<span class="hljs-variable">$sec</span>)) * <span class="hljs-number">1000</span>);<br>     <span class="hljs-keyword">return</span> <span class="hljs-variable">$msectime</span>;<br> &#125;<br><br> <span class="hljs-comment">// 测试执行</span><br> <span class="hljs-keyword">for</span> (<span class="hljs-variable">$i</span>=<span class="hljs-number">0</span>; <span class="hljs-variable">$i</span>&lt;<span class="hljs-number">20</span>; <span class="hljs-variable">$i</span>++)&#123;<br>     var_dump(isActionAllowed(<span class="hljs-string">&quot;110&quot;</span>, <span class="hljs-string">&quot;reply&quot;</span>, <span class="hljs-number">60</span>, <span class="hljs-number">5</span>)); <span class="hljs-comment">//执行可以发现只有前5次是通过的</span><br> &#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP的生命周期</title>
    <link href="/2020/01/03/PHP%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2020/01/03/PHP%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP的生命周期"><a href="#PHP的生命周期" class="headerlink" title="PHP的生命周期"></a>PHP的生命周期</h1><h3 id="1-0-先从PHP开始说起"><a href="#1-0-先从PHP开始说起" class="headerlink" title="1.0 先从PHP开始说起"></a>1.0 先从PHP开始说起</h3><pre><code>在介绍PHP的生命周期之前，我们先来看一张图，如图1所示:</code></pre><p><img src="PHP%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/3077.jpg"><br>    图1 PHP的生命周期<br>    首先我们先引入一个概念SAPI，SAPI是PHP的应用接入层，是整个PHP框架最外层的部分，像我们平常用的比较多的Fpm和Cli就是SAPI的具体实现，而main函数也定义在对应的SAPI中。通常来说PHP的生命周期被划分为5个阶段：模块初始化阶段、请求初始化阶段、脚本执行阶段、请求关闭阶段和模块关闭阶段。在不同的SAPI中，各阶段的调用过程也略有不同，像Cli模式基本会按照顺序完整的执行一遍，而在FastCgi也就是Fpm模式中，只会在启动时执行一次模块初始化，后面的每个请求都只会执行请求初始化阶段、脚本执行阶段和请求关闭阶段，最后在SAPI关闭时执行模块关闭阶段。<br><strong>1.1 模块初始化阶段</strong><br>    这个阶段大概流程如图2-1-1所示：<br><img src="PHP%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/3082.jpg">图1-1 PHP的模块初始化阶段<br>    首先是激活SAPI,对SG宏进行初始化。接着初始化代表PHP输出的OG宏、调用gc_globals_ctor初始化垃圾回收相关的变量。再之后就是正式对Zend引擎进行初始化操作,这块主要进行了如下操作：</p><ul><li><pre><code>启动内存管理器（start_memory_manager）</code></pre></li><li><pre><code>设置Zend编译器、执行器函数句柄</code></pre>zend_compile_file = compile_file;<br>zend_execute_ex = execute_ex;</li><li><pre><code>初始化opcode执行句柄（zend_init_opcodes_handlers）,以供执行阶段执行opcode使用</code></pre></li><li><pre><code>为（函数符号表）GLOBAL_FUNCTION_TABLE，（类符号表）GLOBAL_CLASS_TABLE，（超全局符号表）GLOBAL_AUTO_GLOBALS_TABLE和（常量符号表）GLOBAL_CONSTANTS_TABLE分配内存空间并初始化到CG宏中</code></pre>GLOBAL_FUNCTION_TABLE = (HashTable *) malloc(sizeof(HashTable));<br>GLOBAL_CLASS_TABLE = (HashTable *) malloc(sizeof(HashTable));<br>GLOBAL_AUTO_GLOBALS_TABLE = (HashTable *) malloc(sizeof(HashTable));<br>GLOBAL_CONSTANTS_TABLE = (HashTable *) malloc(sizeof(HashTable));</li><li><pre><code>初始化INI和PHP全局扫描器，这两个扫描器主要是为了解析php.ini文件和PHP脚本</code></pre>ini_scanner_globals_ctor(&amp;ini_scanner_globals);<br>php_scanner_globals_ctor(&amp;language_scanner_globals);</li><li><pre><code>初始化$GLOBALS超全局变量</code></pre></li><li><pre><code>给registered_zend_ini_directives分配内存并初始化到EG(ini_directives)中</code></pre>在Zend引擎初始化完毕之后，紧接着又定义了一些PHP的的全局常量，像我们平常使用的PHP_EOL就是在这里定义的。<br>再往下调用php_init_config函数来读取php.ini文件，设置配置参数。接下来的操作可以分为下面几步：</li><li>注册PHP核心模块的ini配置（REGISTER_INI_ENTRIES）</li><li>注册Zend模块的ini配置（zend_register_standard_ini_entries）</li><li>启动静态编译的扩展（php_register_internal_extensions_func）</li><li>启动附加的扩展，注意在Cli模式中是没有附加的扩展的</li><li>根据php.ini的配置加载扩展（php_ini_register_extensions）</li><li>调用各PHP扩展的PHP_MINIT_FUNCTION启动扩展（zend_startup_modules）</li><li>启动Zend扩展（zend_startup_extensions）</li><li>采集各个扩展的其他阶段的方法句柄，包括RINT，RSHUTDOWN,MSHUTDOWN等（zend_collect_module_handlers）</li><li>禁用php.ini配置的类和方法<br>最后关闭SAPI,结束模块初始化阶段，局部关闭内存管理器。在FastCgi模式中该阶段执行完毕后，主进程在生成完子进程之后直接挂起，由子进程Accpect请求之后直接进入循环，执行后面的阶段。</li></ul><p><strong>21.2 请求初始化阶段</strong><br>    这个阶段一般是在请求处理之前经历的一个阶段，即PHP脚本真正执行之前的最后一个阶段。该阶段的执行过程如图2-1-2所示：<br><img src="PHP%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/3078.jpg">1-2 PHP的请求初始化阶段<br>    首先激活PHP输出、重置全局输出、设置输出栈，接下来激活Zend引擎，相关的操作如下：</p><ul><li><pre><code>重置垃圾回收（gc_reset）</code></pre></li><li><pre><code>初始化编译器（init_compiler）</code></pre></li><li><pre><code>初始化执行器（init_executor）</code></pre></li><li><pre><code>启动扫描器为解析脚本做准备（startup_scanner）</code></pre>紧接着激活SAPI，这块操作跟模块初始化相同。然后激活Zend引擎的信号处理、设置超时时间、激活超全局变量、构建Request参数<br>php_build_argv(SG(request_info).query_string, &amp;PG(http_globals)[TRACK_VARS_SERVER]);<br>最后调用各PHP扩展的RINT方法，结束该阶段。</li></ul><p><strong>1.3 脚本执行阶段</strong><br>    这个阶段的主要流程如图2-1-3 ：<br><img src="PHP%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/3081.jpg">图1-3 PHP的脚本执行阶段<br>在这个阶段我们会调用Zend引擎去直接执行脚本文件，在这里我们首先会把脚本文件编译到op_array中<br>，相关的方法我们在模块初始化阶段已经进行过设置，具体编译流程如下：</p><ul><li>使用扫描器解析脚本(open_file_for_scanning)</li><li>编译脚本（zend_compile）<ul><li>清空op_array</li><li>清空AST语法树</li><li>重新创建一个语法树的栈大小32K，栈上偏移24字节用来存放zend_arena结构体</li><li>调用zendparse进行词法解析</li><li>给op_array重新分配内存</li><li>将CG(active_op_array)存到original_active_op_array中</li><li>初始化op_array(init_op_array)并存入CG(active_op_array)</li><li>解析语法树，根据ast生成op_array(zend_compile_top_stmt)</li><li>设置op_array的头和尾<br>  op_array-&gt;line_start = 1;<br>  op_array-&gt;line_end = last_lineno;</li><li><h3 id="生成handler"><a href="#生成handler" class="headerlink" title="生成handler"></a>生成handler</h3>(pass_two)</li><li>将original_active_op_array存到CG(active_op_array)中</li><li>销毁语法树</li><li>销毁语法树空间<br>最后通过调用zend_execute方法执行编译得到的op_array，完成PHP脚本的执行。由此我们可以看到不管是Cli还是FastCgi都是在脚本执行阶段进行PHP代码的解析、编译、执行。但是通常在生产环境中我们的PHP代码是不常变动的，无疑是浪费了不少性能。</li></ul></li><li><em>1.4 请求关闭阶段</em>*<br>   这个阶段具体流程如图2-1-4所示：<br><img src="PHP%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/3080.jpg">图 1-4<br>   首先是清空EG（current_execute_data），因为在zend_executor回调函数中可能会用到。接下来的操作如下：</li><li><pre><code>调用在register_shutdown_function中注册的所有方法</code></pre></li><li><pre><code>调用所有的__destruct方法</code></pre></li><li><pre><code>清空输出缓冲区</code></pre></li><li><pre><code>重置最大执行时间</code></pre></li><li><pre><code>调用所有PHP扩展的RSHUTDOWN方法</code></pre></li><li><pre><code>关闭输出层(发送设置的HTTP头，清除输出句柄)</code></pre></li><li><pre><code>释放shutdown方法</code></pre></li><li><pre><code>销毁超全局变量</code></pre></li><li><pre><code>释放请求相关的全局变量</code></pre></li><li><pre><code>挂起Zend引擎，关闭扫描器、执行器、编译器</code></pre></li><li><pre><code>调用所有扩展的post-RSHUTDOWN方法</code></pre></li><li><pre><code>挂起SAPI</code></pre></li><li><pre><code>释放虚拟CWD内存</code></pre></li><li><pre><code>销毁哈希流</code></pre></li><li><pre><code>关闭内存管理器</code></pre></li><li><pre><code>重置最大超时时间</code></pre>在Cli模式中到这个阶段我们的PHP程序已经基本走进尾声了，但在FastCgi模式中，子进程请求关闭阶段执行之后会重新Accepct请求，然后在进入请求初始化，执行脚本…。</li><li><em>1.5 模块关闭阶段</em>*<br>   不管在哪种模式这个阶段都是PHP生命周期的最后一个阶段，其具体流程如图2-1-5所示:<br><img src="PHP%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/3079.jpg"></li><li><pre><code>清空SAPI</code></pre></li><li><pre><code>关闭Zend引擎</code></pre></li><li><pre><code>销毁过滤器和传输器</code></pre></li><li><pre><code>关闭ini配置</code></pre></li><li><pre><code>关闭输出</code></pre></li><li><pre><code>关闭垃圾回收</code></pre></li><li><em>1.6 小结</em>*<br>   一般来说我们使用PHP更多的是提供Web服务。从FastCgi相信我们不难理解PHP还有个Cgi模式，在这个模式下每次请求过来都会fork出一个子进程处理请求，每次都会执行上面5个阶段，性能十分低下。而FastCgi模式只进行一次模块初始化，通过预先启动一定数量的子进程（父子进程之间共享内存空间，且写时复制），循环执行请求初始化、执行脚本、请求关闭阶段。避免了模块初始化阶段的重复执行和大量进程反复加载，极大的提升了性能。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一周算法学习笔记</title>
    <link href="/2019/12/13/%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/12/13/%E7%AC%AC%E4%B8%80%E5%91%A8%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一周算法学习笔记"><a href="#第一周算法学习笔记" class="headerlink" title="第一周算法学习笔记"></a>第一周算法学习笔记</h1><h4 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h4><ul><li><p>数组</p><ol><li> 数组是线性的数据结构，用一组连续的内存空间存放一组相同类型的数据</li><li> 因为数组在内存是连续存储的，所以可以根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，找出数据。</li><li> 使用的时候需要注意数组会有越界的问题，支持随机访问。</li></ol><p>** 小技巧 **</p><ol><li> 循环遍历 双指针的用法</li><li> 升级维度</li></ol></li><li><p>链表 Linked List 、跳表 Skip List（升维）</p><ol><li> 单向链表 特点是最后的 tail next 指向 none</li><li> 双向链表 指向 head 头的</li><li> 随机访问数据不如数组速度快</li><li> 跳表是可以实现二分查找的有序链表。Redis 中就在使用</li><li> 在跳表中查询任意数据的时间复杂度是 O(logn)</li></ol><p>** 小技巧 ** 1. 要知道 next 节点 list-&gt;next 2. 理解指针或引用的含义</p></li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">for</span>(<span class="hljs-variable">$I</span> = <span class="hljs-number">0</span> ;<span class="hljs-variable">$I</span>&lt;<span class="hljs-variable">$length</span> -<span class="hljs-number">1</span>;++<span class="hljs-variable">$i</span>)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-variable">$j</span>=<span class="hljs-variable">$i</span>+<span class="hljs-number">1</span>;<span class="hljs-variable">$j</span>&lt;<span class="hljs-variable">$j</span>&lt;<span class="hljs-variable">$length</span>;++<span class="hljs-variable">$j</span>)&#123;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库索引</title>
    <link href="/2019/10/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <url>/2019/10/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><ul><li>1.索引的作用：提高数据查询效率</li><li>2.常见索引模型：哈希表、有序数组、搜索树</li><li>3.哈希表：键 - 值(key - value)。</li><li>4.哈希思路：把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置</li><li>5.哈希冲突的处理办法：链表 *</li><li>6.哈希表适用场景：只有等值查询的场景</li><li>7.有序数组：按顺序存储。查询用二分法就可以快速查询，时间复杂度是：O(log(N))</li><li>8.有序数组查询效率高，更新效率低</li><li>9.有序数组的适用场景：静态存储引擎。</li><li>10.二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子</li><li>11.二叉搜索树：查询时间复杂度 O(log(N))，更新时间复杂度 O(log(N))</li><li>12.数据库存储大多不适用二叉树，因为树高过高，会适用 N 叉树</li><li>13.InnoDB 中的索引模型：B+Tree</li><li>14.索引类型：主键索引、非主键索引,主键索引的叶子节点存的是整行的数据(聚簇索引)，非主键索引的叶子节点内容是主键的值(二级索引)</li><li>15.主键索引和普通索引的区别：主键索引只要搜索 ID 这个 B+Tree 即可拿到数据。普通索引先搜索索引拿到主键值，再到主键索引树搜索一次(回表)</li><li>16.一个数据页满了，按照 B+Tree 算法，新增加一个数据页，叫做页分裂，会导致性能下降。空间利用率降低大概 50%。当相邻的两个数据页利用率很低的时候会做数据页合并，合并的过程是分裂过程的逆过程。</li><li>17.从性能和存储空间方面考量，自增主键往往是更合理的选择。</li></ul><h2 id="思考题："><a href="#思考题：" class="headerlink" title="思考题："></a>思考题：</h2><ul><li>如果删除，新建主键索引，会同时去修改普通索引对应的主键索引，性能消耗比较大。</li><li>删除重建普通索引貌似影响不大，不过要注意在业务低谷期操作，避免影响业务。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库事务</title>
    <link href="/2019/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <url>/2019/10/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h3><ul><li>1、务的特性：原子性、一致性、隔离性、持久性</li><li>2、多事务同时执行的时候，可能会出现的问题：脏读、不可重复读、幻读</li><li>3、事务隔离级别：读未提交、读提交、可重复读、串行化</li><li>4、不同事务隔离级别的区别：<br>读未提交：一个事务还未提交，它所做的变更就可以被别的事务看到<br>读提交：一个事务提交之后，它所做的变更才可以被别的事务看到<br>可重复读：一个事务执行过程中看到的数据是一致的。未提交的更改对其他事务是不可见的<br>串行化：对应一个记录会加读写锁，出现冲突的时候，后访问的事务必须等前一个事务执行完成才能继续执行</li><li>5、配置方法：启动参数 transaction-isolation</li><li>6、事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。</li><li>7、回滚日志什么时候删除？系统会判断当没有事务需要用到这些回滚日志的时候，回滚日志会被删除。</li><li>8、什么时候不需要了？当系统里么有比这个回滚日志更早的 read-view 的时候。</li><li>9、为什么尽量不要使用长事务。长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，回滚记录都要保留，这会导致大量占用存储空间。除此之外，长事务还占用锁资源，可能会拖垮库。</li><li>10、事务启动方式：一、显式启动事务语句，begin 或者 start transaction,提交 commit，回滚 rollback；二、set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个 select 语句，事务就启动，并不会自动提交，直到主动执行 commit 或 rollback 或断开连接。</li><li>11、建议使用方法一，如果考虑多一次交互问题，可以使用 commit work and chain 语法。在 autocommit=1 的情况下用 begin 显式启动事务，如果执行 commit 则提交事务。如果执行 commit work and chain 则提交事务并自动启动下一个事务。</li></ul><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ul><li>在开发过程中，尽可能的减小事务范围，少用长事务，如果无法避免，保证逻辑日志空间足够用，并且支持动态日志空间增长。监控 Innodb_trx 表，发现长事务报警。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>压力测试命令</title>
    <link href="/2019/09/16/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4/"/>
    <url>/2019/09/16/%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="压力测试命令"><a href="#压力测试命令" class="headerlink" title="压力测试命令"></a>压力测试命令</h2><h3 id="命令行模式："><a href="#命令行模式：" class="headerlink" title="命令行模式："></a>命令行模式：</h3><p><code>ab -n 100000 -c 128 -k http://127.0.0.1:9501/</code></p><p><code> wrk http://127.0.0.1:9501 -c 256 -t 4 -d 5</code></p><h3 id="安装命令行"><a href="#安装命令行" class="headerlink" title="安装命令行"></a>安装命令行</h3><p><code>apt-get update</code><br><code>apt-get install apache2-utils</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>压力测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IoC与DI</title>
    <link href="/2019/08/29/IoC%E4%B8%8EDI/"/>
    <url>/2019/08/29/IoC%E4%B8%8EDI/</url>
    
    <content type="html"><![CDATA[<h2 id="IoC与DI"><a href="#IoC与DI" class="headerlink" title="IoC与DI"></a>IoC与DI</h2><ul><li>Ioc，即控制反转，把对象的调用权交给容器，通过容器来实现对象的装配和管理</li><li>DI，即依赖注入，对象之间依赖关系由容器在运行期决定，由容器动态的将依赖关系注入到对象之中</li><li>DI 是对 IoC 更完善的描述</li></ul><h3 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h3><ul><li>谁依赖谁？对象实例化依赖容器</li><li>为什么要依赖？对象实例化通过容器自动得到外部依赖</li><li>谁注入谁？容器注入对象的依赖到对象中</li><li>注入了什么？注入了对象的外部依赖</li></ul><h3 id="Hyperf-的依赖注入"><a href="#Hyperf-的依赖注入" class="headerlink" title="Hyperf 的依赖注入"></a>Hyperf 的依赖注入</h3><ul><li>由 hyperf/di 组件提供功能支持</li><li>更符合长生命周期的应用使用</li><li>提供了 注解、注解注入、AOP</li><li>基于 PSR-11 实现，可独立应用于其他框架</li></ul><ol><li>注入方式<ul><li>通过构造方法注入</li><li>通过 @Inject 注解注入</li></ul></li><li>注入类型<ul><li>简单对象注入<ul><li>我们假设 存在一个。UserService 类</li><li>我们希望在其他地方引用该类的依赖</li><li>在类成员属性上定义 @Inject注解，配合@var 的值来完成依赖的注入</li></ul></li><li>抽象工厂注入</li><li>工厂对象注入</li></ul></li></ol><h3 id="注入容器本身"><a href="#注入容器本身" class="headerlink" title="注入容器本身"></a>注入容器本身</h3><ul><li>直接 Psr\Container\ContainerInterface</li><li>通过 Hyperf\Utils\ApplicationContext::getContainer() 获得</li></ul><h3 id="对注解和-DI-的总结"><a href="#对注解和-DI-的总结" class="headerlink" title="对注解和 DI 的总结"></a>对注解和 DI 的总结</h3><ul><li>PHP 语法上没有支持注解，只能基于约束好的规定去从注释上解析</li><li>注解只是元数据定义，实现功能时不利用这些数据的话，没任何作用</li><li>使用了注解的对象必须基于 Hyperf 的DI 容器来创建对象才能生效</li><li>注解可以用在类、类方法、类成员属性上</li><li>DI 容器是负责管理 对象的创建 和 对象的依赖管理的</li><li>DI 容器创建出来的对象是个单例，是长生命周期对象</li><li>通过 $container-&gt;make() 方法 或者 make() 函数创建短生命周期对象</li><li>通过 new 来实例化的对象注解不会生效，依赖需自行管理</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Hyperf</tag>
      
      <tag>网络协议</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>版本约束表达式和lock文件</title>
    <link href="/2019/08/27/%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Clock%E6%96%87%E4%BB%B6/"/>
    <url>/2019/08/27/%E7%89%88%E6%9C%AC%E7%BA%A6%E6%9D%9F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8Clock%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="版本约束表达式和-lock-文件"><a href="#版本约束表达式和-lock-文件" class="headerlink" title="版本约束表达式和 lock 文件"></a>版本约束表达式和 lock 文件</h1><p>#Learning</p><ol><li>什么是语义化版本<br>版本格式：主版本号、次版本号、修订号</li><li>版本约束<ul><li>使用 ~ 波浪号 约束锁定小版本 （很实用，也比较安全）<br><strong>~ 的作用是允许表达式中最后一位变到最大值的</strong> 1. 安装 &gt;=1.1 并且 &lt; 2.0 的版本，可以写成： ～ 1.1 2. 安装 &gt;= 1.1.15 并且 &lt;1.2.0 的版本，可以写成 ～ 1.1.15</li><li>使用 ^ 折音号 约束锁定大版本<br><strong>^ 锁定不允许变的第一位主版本号，允许升级版本到安全的版本</strong> 1. ^1.2.3 相当于 &gt;=1.2.3 &lt; 2.0.0 2. ^0.3 会被当作 &gt;= 0.3.0 &lt; 0.4.0 3. ^1.2 表示任意大于等于 1.2 的 1.x.x 版本</li><li>使用比较操作符、通配符锁定版本范围<ol><li>通过使用比较操作符号直接指定包的范围</li><li>比较操作符包括： &gt;,&gt;= &lt;,&lt;= ,!=</li><li>通配符*</li><li>与，或 ||</li></ol></li><li>指定具体的版本号精确版本<ol><li>可以指定具体的版本，下载指定版本</li><li>比如使用 =3.1.3 就是下载 3.1.3 的版本</li></ol></li></ul></li></ol><h3 id="composer-中的-json-和-lock-的区别"><a href="#composer-中的-json-和-lock-的区别" class="headerlink" title="composer 中的 .json 和 .lock 的区别"></a>composer 中的 .json 和 .lock 的区别</h3><ol><li>根据 json 来生成依赖，并生成 lock （.lock 文件不存在）</li><li>根据 lock 中的版本号来加载依赖。 （.lock 文件存在）</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>composer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生产环境中优化Composer包管理</title>
    <link href="/2019/08/27/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BC%98%E5%8C%96%20Composer%20%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <url>/2019/08/27/%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E4%BC%98%E5%8C%96%20Composer%20%E5%8C%85%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="生产环境中优化-Composer-包管理"><a href="#生产环境中优化-Composer-包管理" class="headerlink" title="生产环境中优化 Composer 包管理"></a>生产环境中优化 Composer 包管理</h1><h3 id="Composer-常用命令"><a href="#Composer-常用命令" class="headerlink" title="Composer 常用命令"></a>Composer 常用命令</h3><ul><li>安装包，根据 composer.json 文件<br><code>composer install</code></li><li>更新包，升级 composer.json 的所有代码库（如果能能升级的话）<br><code>composer update</code></li><li>搜索包，搜索 composer 可用的包<br><code>composer search 关键字</code></li><li>引入包，会在 composer.json 新增一条包配置，并下载该代码<br><code>composer require 包名称</code></li><li>删除包<br><code>composer remove 包名称</code></li><li>生成当前命名空间与类库文件路径的一个映射，运行时加载会直接读取这个映射，加快文件的加载速度<br><code>composer dump-autoload</code></li></ul><h3 id="composer-dumpautoload-o-命令优化执行时间"><a href="#composer-dumpautoload-o-命令优化执行时间" class="headerlink" title="composer dumpautoload -o  命令优化执行时间"></a><code>composer dumpautoload -o </code> 命令优化执行时间</h3><ul><li>重置索引、生产 classmap （这个命令并没有考虑当前 classmap 中找不到目标类时的情况。<br>当加载器找不到目标类时候，仍旧会根据 PSR-4/PSR-0 的规则去文件系统中查找）</li></ul><h3 id="composer-dumpautoload-a-不推荐使用"><a href="#composer-dumpautoload-a-不推荐使用" class="headerlink" title="composer dumpautoload -a  不推荐使用"></a><code>composer dumpautoload -a </code> 不推荐使用</h3><ul><li>和 -o 的区别在于加载器在 classmap 中找不到目标类时，不会再去文件系统中查找（即隐含的认为 classmap 中所有合法的类，不会有其他的类了，除非法调用）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>composer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是 TCP</title>
    <link href="/2019/08/14/%E4%BB%80%E4%B9%88%E6%98%AF%20TCP/"/>
    <url>/2019/08/14/%E4%BB%80%E4%B9%88%E6%98%AF%20TCP/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是-TCP"><a href="#什么是-TCP" class="headerlink" title="什么是 TCP"></a>什么是 TCP</h1><h3 id="TCP-（transmission-Control-Protocol-传输控制协议）-是一种面向连接的、可靠的、基于字节流的传输层通信协议。"><a href="#TCP-（transmission-Control-Protocol-传输控制协议）-是一种面向连接的、可靠的、基于字节流的传输层通信协议。" class="headerlink" title="TCP （transmission Control Protocol 传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议。"></a>TCP （transmission Control Protocol 传输控制协议） 是一种面向连接的、可靠的、基于字节流的传输层通信协议。</h3><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li>连接问题，IP 写错，端口写错 链接会被拒绝</li><li>Operation now in progress 连接超时、丢包、错误 IP、backlog 满了&amp;阻塞&amp;tcp_abort_on_overflow=0</li><li>min(maxconn,backlog). [ ss -it] 查询 backlog 的设置长度</li></ol><h3 id="SYN-Flood-问题"><a href="#SYN-Flood-问题" class="headerlink" title="SYN Flood 问题"></a>SYN Flood 问题</h3><ul><li>tcp_max_syn_backlog</li><li>tcp_synack_retries</li><li>tcp_syncookies</li></ul><h3 id="短链接性能问题"><a href="#短链接性能问题" class="headerlink" title="短链接性能问题"></a>短链接性能问题</h3><ul><li>多余链接</li><li>启动比较慢、慢启动</li><li>握手阶段丢包</li><li>对链接的占用约等于长链接<br>短链接优点</li><li>简单</li><li>理论上链接数会少</li><li>无状态对负载均衡 LB 友好</li></ul><h3 id="长链接常见问题"><a href="#长链接常见问题" class="headerlink" title="长链接常见问题"></a>长链接常见问题</h3><ul><li>链接失效两种问题<ol><li> redis：timeout(Error while reading line from the server)</li><li> Mysql: wait_timeout &amp; interactive_timeout(has gone away)</li></ol></li><li>链接失效解决方法<ol><li> 用的时候多链接几次 （最简单）</li><li> 定时发心跳维持链接 （推荐方式）</li><li> 利用 swoole 底层的 hearlbeat_idle_time 和 hearlbeat_check_interval (只能针对服务器端，需要客户端配合发心跳）</li></ol></li><li>如何实现应用层心跳<ol><li> 制定 ping/pong 协议 （mysql 等自带 ping 协议）</li><li> 客户端灵活的发送 ping 心跳包</li><li> 服务端 OnRecive 检查可用性回复 pong</li></ol></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络协议</tag>
      
      <tag>TCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>和小朋友沟通直接说感觉比说道理有用</title>
    <link href="/2019/07/11/%E5%92%8C%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%B2%9F%E9%80%9A%E7%9B%B4%E6%8E%A5%E8%AF%B4%E6%84%9F%E8%A7%89%E6%AF%94%E8%AF%B4%E9%81%93%E7%90%86%E6%9C%89%E7%94%A8/"/>
    <url>/2019/07/11/%E5%92%8C%E5%B0%8F%E6%9C%8B%E5%8F%8B%E6%B2%9F%E9%80%9A%E7%9B%B4%E6%8E%A5%E8%AF%B4%E6%84%9F%E8%A7%89%E6%AF%94%E8%AF%B4%E9%81%93%E7%90%86%E6%9C%89%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="随笔"><a href="#随笔" class="headerlink" title="随笔"></a>随笔</h1><p>我来分享一个小故事。有一次，我住在一个朋友家，他家有一个五六岁的小女孩。小女孩很喜欢我，总是往我的房间跑，而我房间的锁坏了，所以她一推门就可以进来。</p><p>一天早上，我在房间里处理一些重要的事，非常需要安静，而小女孩多次不敲门就跑进来，我屡屡被打断，感觉很不好。我试着用各种语言对小女孩说，我需要独处一会儿，请你不要不敲门进来，一会儿我的事处理好了，我会出去找你。</p><p>但我的这些努力都没有用，小女孩像没听见一样，一会儿就闯进来一下，我的思路不断被打断。有点懊恼的时候，我突然问自己，你在干吗？你竟然试着给一个五六岁的小女孩讲道理，而孩子常常是听不见道理的，他们需要的是你给他们讲感受。</p><p>想明白这一点后，她再一次闯进来时，我看着她的小脸，非常认真地对她说：你一次次不敲门就闯进来，我很不高兴，接下来请你不要再这样做了，我忙完了会出去找你。</p><p>这次她终于听进了我的话，特别是“我很不高兴”这句话，让她突然愣了一下。然后再接下来的半个小时内，她再也没有闯进来，而我利用这段时间把自己的事忙完后，主动打开门找她玩了一会儿。</p>]]></content>
    
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>读书</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Workflow</title>
    <link href="/2019/05/16/Git%20Workflow/"/>
    <url>/2019/05/16/Git%20Workflow/</url>
    
    <content type="html"><![CDATA[<h1 id="Git-Workflow"><a href="#Git-Workflow" class="headerlink" title="Git Workflow"></a>Git Workflow</h1><ol><li>git remote add upstream // 必须添加一个上由主分支的地址 可以用 git remote -v 来查看</li><li>git pull upstream master // 拿到项目的主分支代码</li><li>git checkout -b // 创建自己飞分支</li><li>git commit // 写完代码之后提交</li><li>git checkout 分支名 // 切换到主分支</li><li>git pull upstream master // 提交之前再次获取线上最新代码</li><li>git checkout &amp;&amp; git rebase master</li><li>git push origin branch</li></ol><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ul><li>获取上游新建的分支。 git fetch upstream</li><li>取消红色状态的文件。git checkout — 文件名</li><li>取消蓝色状态的文件： git reset Head [文件名字]</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 技巧总结</title>
    <link href="/2019/05/11/Golang%20%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2019/05/11/Golang%20%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-技巧总结"><a href="#Golang-技巧总结" class="headerlink" title="Golang 技巧总结"></a>Golang 技巧总结</h1><h3 id="时间格式化"><a href="#时间格式化" class="headerlink" title="时间格式化"></a><strong>时间格式化</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time := time2.Now().Format(“2006-01-02 15:04:05”)</span><br></pre></td></tr></table></figure><h3 id="http库-request-body-只能读取一次"><a href="#http库-request-body-只能读取一次" class="headerlink" title="http库 request body 只能读取一次"></a><strong>http库 request body 只能读取一次</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.ReadAll(r.Body) // 第一次有数据 第二次为空，但是不代表错误</span><br><span class="line">要注意多次读取的问题</span><br></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Go 技巧总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go http 服务默认的路由规则和更好的路由</title>
    <link href="/2019/04/24/Go%20http%20%E6%9C%8D%E5%8A%A1%E9%BB%98%E8%AE%A4%E7%9A%84%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E5%92%8C%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%B7%AF%E7%94%B1/"/>
    <url>/2019/04/24/Go%20http%20%E6%9C%8D%E5%8A%A1%E9%BB%98%E8%AE%A4%E7%9A%84%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99%E5%92%8C%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-http-服务默认的路由规则和更好的路由"><a href="#Go-http-服务默认的路由规则和更好的路由" class="headerlink" title="Go http 服务默认的路由规则和更好的路由"></a>Go http 服务默认的路由规则和更好的路由</h1><h2 id="Go-Default-Router"><a href="#Go-Default-Router" class="headerlink" title="Go Default Router"></a>Go Default Router</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">func (sh serverHandler) ServeHTTP(rw ResponseWriter, req *Request)&#123;<br>    <span class="hljs-keyword">handler</span> := sh.srv.<span class="hljs-keyword">Handler</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">handler</span> == nil &#123;<br>        <span class="hljs-keyword">handler</span> = DefaultServeMux // 使用缺省的Router<br>    &#125;<br>    <span class="hljs-keyword">if</span> req.RequestURI == “*” &amp;&amp; req.<span class="hljs-keyword">Method</span> == “<span class="hljs-keyword">OPTIONS</span>” &#123;<br>        <span class="hljs-keyword">handler</span> = globlOptionsHandler&#123;&#125;<br>    &#125;<br>    <span class="hljs-keyword">handler</span>.ServeHTTP(rw,req)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="路由规则"><a href="#路由规则" class="headerlink" title="路由规则"></a>路由规则</h2><ul><li>URL 分为两种，末尾是 /： 表示一个子树，后面可以跟其他的子路径；末尾不是 / ，表示一个叶子，固定的路径<br>以 /结尾的 URL 可以匹配它的任何子路径，比如 /images 回匹配 /images/cute-cat.jpg*</li><li>它采用最长匹配原则，如果多个匹配，一定采用匹配路径最长的那个进行处理</li><li>如果没有找到任何匹配项，会返回 404</li></ul><h2 id="更好的-Router"><a href="#更好的-Router" class="headerlink" title="更好的 Router"></a>更好的 Router</h2><p><a href="https://github.com/julienschmidt/httprouter">https://github.com/julienschmidt/httprouter</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span><br><br>import (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;github.com/julienschmidt/httprouter&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br>func Index(w http<span class="hljs-selector-class">.ResponseWriter</span>, r *http<span class="hljs-selector-class">.Request</span>, _ httprouter.Params) &#123;<br>    fmt<span class="hljs-selector-class">.Fprint</span>(w, <span class="hljs-string">&quot;Welcome!\n&quot;</span>)<br>&#125;<br><br>func Hello(w http<span class="hljs-selector-class">.ResponseWriter</span>, r *http<span class="hljs-selector-class">.Request</span>, ps httprouter.Params) &#123;<br>    fmt<span class="hljs-selector-class">.Fprintf</span>(w, <span class="hljs-string">&quot;hello, %s!\n&quot;</span>, ps<span class="hljs-selector-class">.ByName</span>(<span class="hljs-string">&quot;name&quot;</span>))<br>&#125;<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br>    router := httprouter<span class="hljs-selector-class">.New</span>()<br>    router<span class="hljs-selector-class">.GET</span>(<span class="hljs-string">&quot;/&quot;</span>, Index)<br>    router<span class="hljs-selector-class">.GET</span>(<span class="hljs-string">&quot;/hello/:name&quot;</span>, Hello)<br><br>    log<span class="hljs-selector-class">.Fatal</span>(http<span class="hljs-selector-class">.ListenAndServe</span>(<span class="hljs-string">&quot;:8080&quot;</span>, router))<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 内置的 JSON 解析</title>
    <link href="/2019/04/24/Go%20%E5%86%85%E7%BD%AE%E7%9A%84%20JSON%20%E8%A7%A3%E6%9E%90/"/>
    <url>/2019/04/24/Go%20%E5%86%85%E7%BD%AE%E7%9A%84%20JSON%20%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-内置的-JSON-解析"><a href="#Go-内置的-JSON-解析" class="headerlink" title="Go 内置的 JSON 解析"></a>Go 内置的 JSON 解析</h1><ul><li>利用反射实现，通过 FelidTag 来标识对应的 json 值</li></ul><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">BasicInfo</span> struct &#123;<br>    <span class="hljs-type">Name</span> string `json:&quot;name&quot;`<br>    <span class="hljs-type">Age</span>  int    `json:&quot;age&quot;`<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">JobInfo</span> struct &#123;<br>  <span class="hljs-type">Skills</span> []string `json:&quot;skills&quot;`<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-type">Employee</span> struct &#123;<br>  <span class="hljs-type">BasicInfo</span> <span class="hljs-type">BasicInfo</span> `json:&quot;basic_info&quot;`<br>  <span class="hljs-type">JobInfo</span>   <span class="hljs-type">JobInfo</span>   `json:&quot;job_info&quot;`<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>更快的 JSON 解析<br>EasyJSON 采用代码生成而非反射</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">安装： <span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/mailru/easyjson/<br><br>使用: easyjson -<span class="hljs-keyword">all</span> &lt;文件名，一般只结构定义的文件&gt;.<span class="hljs-keyword">go</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Package</title>
    <link href="/2019/03/18/Go%20Package/"/>
    <url>/2019/03/18/Go%20Package/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Package"><a href="#Go-Package" class="headerlink" title="Go Package"></a>Go Package</h1><ol><li>基本复用模块单元<br>以首字母大写来表明可以被包外代码访问</li><li>代码的 package 可以和所在的目录不一致</li><li>同一目录里面的 Go 代码的 package 要保持一致</li></ol><h4 id="init-方法"><a href="#init-方法" class="headerlink" title="init 方法"></a>init 方法</h4><ul><li>在 main 被执行前,所以依赖的 package init 方法都会被执行</li><li>不同包的 init 函数按照包倒入的依赖关系决定执行顺序</li><li>每个包可以有多个 init 函数</li><li>包的每个源文件也可以有多个 init 函数 ,这点比较特殊</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 错误处理 Panic 和 Recover</title>
    <link href="/2019/03/18/Go%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%20Panic%20%E5%92%8C%20Recover/"/>
    <url>/2019/03/18/Go%20%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%20Panic%20%E5%92%8C%20Recover/</url>
    
    <content type="html"><![CDATA[<h4 id="Go-错误处理-Panic-和-Recover"><a href="#Go-错误处理-Panic-和-Recover" class="headerlink" title="Go 错误处理 Panic 和 Recover"></a>Go 错误处理 Panic 和 Recover</h4><ol><li>Go 中没有错误机制</li><li>error 类型实现了 error 接口</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">type <span class="hljs-builtin-name">error</span><span class="hljs-built_in"> interface </span>&#123;<br><span class="hljs-builtin-name">Error</span>() string<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>可以通过 errors.New 来实现快速创建错误信息</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">errors.New(<span class="hljs-comment">&quot;n must be in the range [0,10]</span><br></code></pre></td></tr></table></figure><h4 id="Panic-的基本定义和使用"><a href="#Panic-的基本定义和使用" class="headerlink" title="Panic 的基本定义和使用"></a>Panic 的基本定义和使用</h4><ol><li>panic 用于不可以恢复的错误</li><li>Panic 退出前会执行 defer 指定的内容、</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPanic</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;最后结果依旧执行!&quot;</span>) <span class="hljs-comment">// 这一部分的代码依旧执行</span><br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;执行开始&quot;</span>)<br><span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;错误信息!&quot;</span>))<br>&#125;<br><span class="hljs-comment">// 输出大致结果如下</span><br>开始<br>最后结果依旧执行!<br>--- FAIL: TestPanic (<span class="hljs-number">0.00</span>s)<br><span class="hljs-built_in">panic</span>: 错误信息! [recovered]<br><span class="hljs-built_in">panic</span>: 错误信息!<br></code></pre></td></tr></table></figure><h4 id="os-Exit-的基本定义和使用"><a href="#os-Exit-的基本定义和使用" class="headerlink" title="os.Exit 的基本定义和使用"></a>os.Exit 的基本定义和使用</h4><ol><li>os.Exit 退出时不调用 defer 指定的函数</li><li>os.Exit 退出时不输出当前调用栈信息</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> TestExit(t *testing.T) &#123;<br>defer <span class="hljs-keyword">func</span>() &#123;<br>fmt.Println(<span class="hljs-string">&quot;这段代码不会执行!&quot;</span>)<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;开始执行&quot;</span>)<br>os.Exit(-<span class="hljs-number">1</span>) <span class="hljs-regexp">//</span> 直接退出 <span class="hljs-keyword">exit</span> status <span class="hljs-number">255</span><br>&#125;<br><span class="hljs-regexp">//</span> 输出结果如下<br>开始执行<br><span class="hljs-keyword">exit</span> status <span class="hljs-number">255</span><br><br></code></pre></td></tr></table></figure><h4 id="Recover-的使用"><a href="#Recover-的使用" class="headerlink" title="Recover 的使用"></a>Recover 的使用</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestRecover</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;recoverd 开始\n&quot;</span>, err)<br>&#125;<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;开始执行&quot;</span>)<br><span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;错误信息!&quot;</span>))<br>&#125;<br><span class="hljs-comment">// 输出结果如下:</span><br>开始执行<br>recoverd 开始<br> 错误信息!<br></code></pre></td></tr></table></figure><h4 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h4><pre><code>当一个函数在执行过程中出现了异常或遇到 panic()，正常语句就会立即终止，然后执行 defer 语句，再报告异常信息，最后退出。如果在 defer 中使用了 recover() 函数,则会捕获错误信息，使该错误信息终止报告。</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go interface</title>
    <link href="/2019/03/18/Go%20interface%202/"/>
    <url>/2019/03/18/Go%20interface%202/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-interface"><a href="#Go-interface" class="headerlink" title="Go interface"></a>Go interface</h1><ul><li>通过关键字 type 和 interface，声明出接口类 <code>type TestInterface interface &#123;&#125;</code></li><li>因为接口类型与其他数据类型不同，它是没法被实例化的。既不能通过调用 new 函数或 make 函数创建出一个接口类型的值</li><li>我们通过 interface 来定义对象的一组行为方法，如果某个对象实现了某个接口类型的所有方法，则此对象就是这个接口的实现类型<br>实现约束: 1. 两个方法的签名需要完全一致 2. 两个方法的名称要一模一样</li></ul><p>代码实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pet <span class="hljs-keyword">interface</span> &#123;<br>    SetName(name <span class="hljs-keyword">string</span>)<br>    Name() <span class="hljs-keyword">string</span><br>    Category() <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>    name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog *Dog)</span> <span class="hljs-title">SetName</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span></span> &#123;<br>    dog.name = name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog Dog)</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">return</span> dog.name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dog Dog)</span> <span class="hljs-title">Category</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;dog&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDog</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    dog := Dog&#123;<span class="hljs-string">&quot;little pig&quot;</span>&#125;<br>    _, ok := <span class="hljs-keyword">interface</span>&#123;&#125;(dog).(Pet)<br>    fmt.Printf(<span class="hljs-string">&quot;Dog implements interface Pet: %v\n&quot;</span>, ok) <span class="hljs-comment">// Dog implements interface Pet: false</span><br>    _, ok = <span class="hljs-keyword">interface</span>&#123;&#125;(&amp;dog).(Pet)<br>    fmt.Printf(<span class="hljs-string">&quot;*Dog implements interface Pet: %v\n&quot;</span>, ok) <span class="hljs-comment">// *Dog implements interface Pet: true</span><br>    <span class="hljs-keyword">var</span> pet Pet = &amp;dog<br>    fmt.Printf(<span class="hljs-string">&quot;This pet is a %s, the name is %q.\n&quot;</span>,<br>        pet.Category(), pet.Name()) <span class="hljs-comment">//  This pet is a dog, the name is &quot;little pig&quot;.</span><br><br>    dog.SetName(<span class="hljs-string">&quot;monster&quot;</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;This pet is a %s, the name is %q.\n&quot;</span>,<br>        pet.Category(), pet.Name()) <span class="hljs-comment">// This pet is a dog, the name is &quot;monster&quot;.</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><ol><li>空接口可以表示任何类型</li><li>2.通过断言来将空接口转换为制定 // v,ok := p.(int) // ok = true 时转换成功</li></ol><h3 id="go-接口最佳实践"><a href="#go-接口最佳实践" class="headerlink" title="go 接口最佳实践"></a>go 接口最佳实践</h3><h4 id="倾向于使用小的接口定义-很多接口只包含一个方法"><a href="#倾向于使用小的接口定义-很多接口只包含一个方法" class="headerlink" title="倾向于使用小的接口定义,很多接口只包含一个方法"></a>倾向于使用小的接口定义,很多接口只包含一个方法</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">type</span> Reader interface &#123;<br><span class="hljs-constructor">Read(<span class="hljs-params">p</span> []<span class="hljs-params">byte</span>)</span> (n <span class="hljs-built_in">int</span>, err error)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="较大的接口定义-可以由多个小接口定义组合而成"><a href="#较大的接口定义-可以由多个小接口定义组合而成" class="headerlink" title="较大的接口定义,可以由多个小接口定义组合而成"></a>较大的接口定义,可以由多个小接口定义组合而成</h4><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-keyword">type</span> <span class="hljs-type">ReadWrite</span> interface &#123;<br><span class="hljs-type">Reader</span><br><span class="hljs-type">Write</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="只依赖与必要的功能最小接口"><a href="#只依赖与必要的功能最小接口" class="headerlink" title="只依赖与必要的功能最小接口**"></a>只依赖与必要的功能最小接口**</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">storeData</span>(reader <span class="hljs-type">Reader</span>)</span> error &#123;<br>  <span class="hljs-operator">…</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h4><p>使用者来定义接口，不是先写好了个接口，然后使用者来调用</p><p>接口变量里面有实现者的类型和实现者的值</p><p>接口变量里面自带指针，<br>接口变量同样采用值传递，几乎不需要使用接口的指针<br>指针接收者实现只能以指针方式使用，值接收者的话两者都可</p><p>查看接口变量的类型<br>表示任何类型 interface{}<br>查看接口变量<br>type switch type Assertion</p>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 面向对象</title>
    <link href="/2019/03/13/Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/03/13/Go%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-面向对象"><a href="#Go-面向对象" class="headerlink" title="Go 面向对象"></a>Go 面向对象</h1><h3 id="实例创建及初始化"><a href="#实例创建及初始化" class="headerlink" title="实例创建及初始化"></a>实例创建及初始化</h3><ul><li>基本使用</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>Id   <span class="hljs-keyword">int</span><br>Name <span class="hljs-keyword">string</span><br>Age  <span class="hljs-keyword">int</span><br>&#125;<br><br>e  := Employee&#123;<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>&#125;<br>e1 := Employee&#123;name: <span class="hljs-string">&quot;Ali&quot;</span>, Age: <span class="hljs-number">30</span>&#125;<br><span class="hljs-comment">// 注意这里返回的引用/指针, 相当于 e:= &amp;Employee&#123;&#125;</span><br>e2 := <span class="hljs-built_in">new</span>(Employee)<br><span class="hljs-comment">// 与其他的编程语言不同, 可以不用 -&gt; 的方式来访问指定的属性</span><br>e2.Id = <span class="hljs-string">&quot;2&quot;</span><br>e2.Age = <span class="hljs-number">23</span><br>e2.Name = <span class="hljs-string">&quot;Ali&quot;</span><br><span class="hljs-comment">// 访问</span><br>t.Log(e1.Id)           <span class="hljs-comment">// 0</span><br>t.Logf(<span class="hljs-string">&quot;e is %T&quot;</span>, e)   <span class="hljs-comment">// e is employee_test.Employee 前面如果加上 &amp;  那么返回的也是 指针类型</span><br>t.Logf(<span class="hljs-string">&quot;e2 is %T&quot;</span>, e2) <span class="hljs-comment">// e2 is *employee_test.Employee 这个是指针类型</span><br></code></pre></td></tr></table></figure><ul><li>非指针传递会生成一个新的结构对象，其中每个成员会复制。指针传递，只是传递指针，且该指针指向原有结构。</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 这一种,定义方式在实例对应方法变调用的时候 ,实例的成员会进行值复制<br><span class="hljs-keyword">func</span> (e Employee) String() string &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;输出自己的e的地址 %x\n&quot;</span>, unsafe.Pointer(&amp;e.Name)) <span class="hljs-regexp">//</span> c00000a0e8<br>  return fmt.Sprintf(<span class="hljs-string">&quot;ID :%d-Name:%s-Age:%d&quot;</span>, e.Id, e.Name, e.Age)<br>&#125;<br><br><span class="hljs-regexp">//</span> 在通常情况下避免内存拷贝我们使用 这种方式<br><span class="hljs-keyword">func</span> (e *Employee) String() string &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;输出自己的e的地址 %x\n&quot;</span>, unsafe.Pointer(&amp;e.Name)) <span class="hljs-regexp">//</span> c00000a0e8<br>    return fmt.Sprintf(<span class="hljs-string">&quot;ID :%d/Name:%s/Age:%d&quot;</span>, e.Id, e.Name, e.Age)<br>&#125;<br><br><span class="hljs-regexp">//</span> 测试 String 方法<br><span class="hljs-keyword">func</span> TestInit(t *testing.T) &#123;<br>    e := Employee&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>&#125;<br>    <span class="hljs-regexp">//</span> 第一种<br>    <span class="hljs-regexp">//</span> t.Log(e.String()) <span class="hljs-regexp">//</span> ID :<span class="hljs-number">1</span>-Name:Bob-Age:<span class="hljs-number">20</span><br>    fmt.Printf(<span class="hljs-string">&quot;输出传进来的e的地址 %x\n&quot;</span>, unsafe.Pointer(&amp;e.Name)) <span class="hljs-regexp">//</span> c00000a108<br><br>    <span class="hljs-regexp">//</span> 第二种<br>    t.Log(e.String()) <span class="hljs-regexp">//</span> ID :<span class="hljs-number">1</span><span class="hljs-regexp">/Name:Bob/</span>Age:<span class="hljs-number">20</span><br>    fmt.Printf(<span class="hljs-string">&quot;输出传进来的e的地址 %x\n&quot;</span>, unsafe.Pointer(&amp;e.Name))  <span class="hljs-regexp">//</span> c00000a0e8<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go String 类型</title>
    <link href="/2019/03/12/Go%20String%20%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/03/12/Go%20String%20%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-String-类型"><a href="#Go-String-类型" class="headerlink" title="Go String 类型"></a>Go String 类型</h1><ul><li>零值 不是 null 是 空字符串</li><li>string 是数据类型,不是引用或者指针类型</li><li>string 是只读的 byte slice, len 函数可以返回它所包含的 byte 数</li><li>string 的 byte 数组可以存放任何数据</li></ul><h4 id="Unicode-UTF8"><a href="#Unicode-UTF8" class="headerlink" title="Unicode UTF8"></a>Unicode UTF8</h4><ol><li>Unicode 是一种字符集 (code point 字符编码)</li><li>UTF8 是 Unicode 的存储实现 (转换为字节序列的规则)</li></ol><h4 id="字符串常用的函数包"><a href="#字符串常用的函数包" class="headerlink" title="字符串常用的函数包"></a>字符串常用的函数包</h4><ol><li>strings 包 (<a href="https://golang.org/pkg/strings/">https://golang.org/pkg/strings/</a>)</li><li>strconv 包 (<a href="https://golang.org/pkg/strconv/">https://golang.org/pkg/strconv/</a>)</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go map类型</title>
    <link href="/2019/03/08/Go%20map%E7%B1%BB%E5%9E%8B/"/>
    <url>/2019/03/08/Go%20map%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-map-类型"><a href="#Go-map-类型" class="headerlink" title="Go map 类型"></a>Go map 类型</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><ul><li>类似其它语言中的哈希表或者字典，以 key=&gt;value 形式存储数据</li><li>格式为 map[keyType]valueType</li><li>key 必须是支持 == 或者 != 比较运算的类型，不可以是函数，map 或者 slice</li><li>map 使用 make() 创建，支持 := 这种简写的方式</li><li>map 是无序的，每次打印出来的 map 都会不一样，它不能通过 index 获取，而必须通过 key 获取</li><li>map 的长度是不固定的，也就是和 slice 一样，也是一种引用类型</li><li>内置的 len 函数同样适用于 map，返回 map 拥有的 key 的数量</li><li>map 的值可以很方便的修改，通过 mapType[“one”] = 11 可以很容易的把 key 为 one 的值改为 11</li><li>和 slice 一样,如果两个 map 同时指向同一个底层数据,那么任何一个改变.另一个也会改变</li></ul><h2 id="代码练习"><a href="#代码练习" class="headerlink" title="代码练习"></a>代码练习</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 声明一个 key 是字符串，值为 int 的map</span><br><span class="hljs-keyword">var</span> numbers <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span><br><span class="hljs-comment">// 另一种声明方式 map 使用 make() 创建</span><br>numbers = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>]<br><br><span class="hljs-comment">// 支持 := 这种简写的方式</span><br>numbers := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br><br>numbers[<span class="hljs-string">&quot;one&quot;</span>] = <span class="hljs-number">1</span>          <span class="hljs-comment">// 赋值</span><br>numbers[<span class="hljs-string">&quot;two&quot;</span>] = <span class="hljs-number">2</span>          <span class="hljs-comment">// 赋值</span><br><span class="hljs-comment">// 注意不能单独打印 numbers 而必须通过 key 获取</span><br>fmt.Println(numbers[<span class="hljs-string">&quot;one&quot;</span>]) <span class="hljs-comment">//  输出 1</span><br><br><span class="hljs-comment">// 初始化一个字典</span><br>rating := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">float32</span>&#123;<span class="hljs-string">&quot;C&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;Go&quot;</span>: <span class="hljs-number">4.5</span>, <span class="hljs-string">&quot;Python&quot;</span>: <span class="hljs-number">4.5</span>, <span class="hljs-string">&quot;PHP&quot;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-comment">// 赋值</span><br>csharpRating, ok := rating[<span class="hljs-string">&quot;C++&quot;</span>]<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;输出ok的值&quot;</span>, csharpRating)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;没找到对应的OK的值&quot;</span>)<br>&#125;<br><span class="hljs-built_in">delete</span>(rating, <span class="hljs-string">&quot;C&quot;</span>)      <span class="hljs-comment">// 删除key为C的元素</span><br>fmt.Println(rating[<span class="hljs-string">&quot;C&quot;</span>]) <span class="hljs-comment">// 输出 0</span><br><span class="hljs-comment">// 内置的len函数同样适用于 map，返回 map 拥有的 key 的数量</span><br>fmt.Println(<span class="hljs-built_in">len</span>(rating)) <span class="hljs-comment">// 因为删除了一个key 所以现在输出 3</span><br><span class="hljs-comment">// 和 slice 一样,如果两个map 同时指向同一个底层数据,那么任何一个改变.另一个也会改变</span><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<br>m[<span class="hljs-string">&quot;Hello&quot;</span>] = <span class="hljs-string">&quot;你好&quot;</span><br>m1 := m<br>m1[<span class="hljs-string">&quot;Hello&quot;</span>] = <span class="hljs-string">&quot;不好&quot;</span>  <span class="hljs-comment">// 现在m[&quot;hello&quot;]的值已经是 不好 了</span><br><span class="hljs-comment">//  key 必须是支持 == 或者 != 比较运算的类型，不可以是函数，map 或者 slice</span><br>mapa := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>:<span class="hljs-number">1</span>,<span class="hljs-string">&quot;two&quot;</span>:<span class="hljs-number">2</span>&#125;<br>mapb := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-string">&quot;yi&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;er&quot;</span>: <span class="hljs-number">2</span>&#125;<br><span class="hljs-keyword">if</span> mapa[<span class="hljs-string">&quot;one&quot;</span>] == mapb[<span class="hljs-string">&quot;yi&quot;</span>] &#123;<br>fmt.Println(<span class="hljs-string">&quot;可以比较&quot;</span>)<br>&#125;<br><span class="hljs-keyword">if</span> mapa[<span class="hljs-string">&quot;one&quot;</span>] != mapb[<span class="hljs-string">&quot;er&quot;</span>] &#123;<br>fmt.Println(<span class="hljs-string">&quot;可以比较&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 函数</title>
    <link href="/2019/03/08/Go%20%E5%87%BD%E6%95%B0/"/>
    <url>/2019/03/08/Go%20%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-函数"><a href="#Go-函数" class="headerlink" title="Go 函数"></a>Go 函数</h1><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><ul><li>关键字 <code>func</code> 用来声明一个函数</li><li>函数可以有一个或者多个参数，每个参数后面带有不同的类型，通过,分隔</li><li>函数可以返回多个值</li><li>如果只有一个返回值且不声明返回值变量，那么你可以省略 包括返回值 的括号</li><li>如果没有返回值，那么就直接省略最后的返回信息</li><li>如果有返回值， 那么必须在函数的外层添加 return 语句</li><li>所有的参数都是值传递: slice, map, channel 会有传引用的错觉</li><li>函数可以作为变量的值</li><li>函数可以作为参数的返回值</li></ul><h2 id="函数基本定义"><a href="#函数基本定义" class="headerlink" title="函数基本定义"></a>函数基本定义</h2><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 函数定义</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcName</span><span class="hljs-params">(inputOne <span class="hljs-keyword">type</span>, inputTwo <span class="hljs-keyword">type</span>)</span> <span class="hljs-params">(outputOne <span class="hljs-keyword">type</span>, outputTwo <span class="hljs-keyword">type</span>)</span></span> &#123;**<br><span class="hljs-comment">// 逻辑代码...</span><br><span class="hljs-comment">// 可以返回多个值</span><br><span class="hljs-keyword">return</span> valueOne, valueTwo<br>&#125;<br><span class="hljs-comment">// 返回指定类型</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Testmax</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> a &gt; b &#123;<br><span class="hljs-keyword">return</span> a<br>&#125;<br><span class="hljs-keyword">return</span> b<br>&#125;<br><br><span class="hljs-comment">// 返回两个值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SumAndProduct</span><span class="hljs-params">(A, B <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span> A+B, A*B<br>&#125;<br><br><span class="hljs-comment">// 不确定传入的参数个数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sum</span><span class="hljs-params">(ops ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span>&#123;<br>ret :=<span class="hljs-number">0</span><br> <span class="hljs-keyword">for</span> _,op:=<span class="hljs-keyword">range</span> ops&#123;<br>ret += op<br> &#125;<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP 技巧总结</title>
    <link href="/2018/02/11/PHP%20%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2018/02/11/PHP%20%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="PHP-技巧总结"><a href="#PHP-技巧总结" class="headerlink" title="PHP 技巧总结"></a>PHP 技巧总结</h1><h3 id="二维数组根据某个字段进行排序"><a href="#二维数组根据某个字段进行排序" class="headerlink" title="二维数组根据某个字段进行排序"></a><strong>二维数组根据某个字段进行排序</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一个字段排序</span><br><span class="line">array_multisort(array_column($data, &#x27;sort&#x27;), SORT_DESC, $data);</span><br><span class="line">多个字段排序</span><br><span class="line">array_multisort(array_column($data, &#x27;sort1&#x27;), SORT_DESC, array_column($data, &#x27;sort2&#x27;), SORT_DESC, $data);</span><br></pre></td></tr></table></figure><h3 id="二维数据根据某个-key-当键名"><a href="#二维数据根据某个-key-当键名" class="headerlink" title="二维数据根据某个 key 当键名"></a><strong>二维数据根据某个 key 当键名</strong></h3><p><code>array_column($arr,$column_name,$key_name)</code></p><h3 id="删除数组中的重复项"><a href="#删除数组中的重复项" class="headerlink" title="删除数组中的重复项"></a><strong>删除数组中的重复项</strong></h3><p><code>array_keys(array_flip($array));</code></p><h3 id="获取随机数组记录"><a href="#获取随机数组记录" class="headerlink" title="获取随机数组记录"></a><strong>获取随机数组记录</strong></h3><p><code>$array[mt_rand(0, count($array) - 1)];</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>PHP</tag>
      
      <tag>PHP 技巧总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
